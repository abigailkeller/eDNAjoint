expect_error(detectionPlot(model1$model, mu.min = 0.1, mu.max = 0.1, cov.val = c(0,0)),
"mu.max must be a numeric value greater than mu.min")
#6. make sure mu.max is a numeric value
expect_error(detectionPlot(model1$model, mu.min = 0.1, mu.max = 1, cov.val = c(0,0), probability = 1.1),
"probability must be a numeric value between 0 and 1")
#7. cov.val is numeric, if provided
expect_error(detectionPlot(model1$model, mu.min = 0.1, mu.max = 1, cov.val = c(0,'0')),
"cov.val must be a numeric vector")
#8. Only include input cov.val if covariates are included in model
expect_error(detectionPlot(model2$model, mu.min = 0.1, mu.max = 1, cov.val = c(0,0)),
"cov.val must be 'None' if the model does not contain site-level covariates.")
#9. Input cov.val is the same length as the number of estimated covariates.
expect_error(detectionPlot(model1$model, mu.min = 0.1, mu.max = 1, cov.val = c(0,0,0)),
"cov.val must be of the same length as the number of non-intercept site-level coefficients in the model.")
#10. If covariates are in model, cov.val must be provided
expect_error(detectionPlot(model1$model, mu.min = 0.1, mu.max = 1),
"cov.val must be provided if the model contains site-level covariates.")
#11. qPCR.N must be an integer
expect_error(detectionPlot(model1$model, mu.min = 0.1, mu.max = 1, qPCR.N = 6.8),
"qPCR.N should be an integer.")
#11. qPCR.N must be an integer
expect_error(detectionPlot(model1$model, mu.min = 0.1, mu.max = 1, cov.val = c(0,0), qPCR.N = 6.8),
"qPCR.N should be an integer.")
#1. make sure model fit is of class stanfit
data <- data.frame(y=c(1,2,3),x=c(1,2,3))
lm_out <- lm(y ~ x, data=data)
expect_error(jointSummarize(lm_out$model),
"modelfit must be of class 'stanfit'.")
out <- model2
#2. make sure probs is a numeric vector
expect_error(jointSummarize(out$model,probs=c('95%')),
"probs must be a numeric vector.")
#3. make sure all values of probs are between 0 and 1
expect_error(jointSummarize(out$model,probs=c(5,95)),
"probs must be between 0 and 1.")
#4. make sure par is a character vector
expect_error(jointSummarize(out$model,par=c(1,2,3)),
"par must be a character vector.")
#5. make sure model fit contains all par input
expect_error(jointSummarize(out$model,par='alpha'),
"modelfit must contain all selected parameters: alpha")
#1. make sure model fit is of class stanfit
expect_error(muCritical(as.matrix(model1$model), cov.val = c(0,0)),
"modelfit must be of class 'stanfit'.")
#2. make sure ci is valid
expect_error(muCritical(model1$model, ci = 1, cov.val = c(0,0)),
"ci must be a numeric value >0 and <1.")
#3. make sure model fit contains p10 parameter
expect_error(muCritical(model2$model),
"modelfit must contain 'p10' parameter.")
#4. if modelfit contains alpha, cov.val must be provided
expect_error(muCritical(model1$model),
"If modelfit contains site-level covariates, values must be provided for cov.val")
#5. cov.val is numeric, if provided
expect_error(muCritical(model1$model, cov.val=c(TRUE,TRUE)),
"cov.val must be a numeric vector")
#6. Only include input cov.val if covariates are included in model
expect_error(muCritical(model3$model, cov.val=c(0,0)),
"cov.val must be 'None' if the model does not contain site-level covariates.")
#6. Only include input cov.val if covariates are included in model
expect_error(muCritical(model2$model, cov.val=c(0,0)),
"cov.val must be 'None' if the model does not contain site-level covariates.")
#7. Only include input cov.val if covariates are included in model
expect_error(muCritical(model1$model, cov.val=c(0,0,0)),
"cov.val must be of the same length as the number of non-intercept site-level coefficients in the model.")
#1. make sure model fit is of class stanfit
expect_error(muCritical(as.matrix(model1$model), cov.val = c(0,0)),
"modelfit must be of class 'stanfit'.")
#2. make sure ci is valid
expect_error(muCritical(model1$model, ci = 1, cov.val = c(0,0)),
"ci must be a numeric value >0 and <1.")
#3. make sure model fit contains p10 parameter
expect_error(muCritical(model2$model),
"modelfit must contain 'p10' parameter.")
#4. if modelfit contains alpha, cov.val must be provided
expect_error(muCritical(model1$model),
"If modelfit contains site-level covariates, values must be provided for cov.val")
#5. cov.val is numeric, if provided
expect_error(muCritical(model1$model, cov.val=c(TRUE,TRUE)),
"cov.val must be a numeric vector")
#6. Only include input cov.val if covariates are included in model
expect_error(muCritical(model2$model, cov.val=c(0,0)),
"cov.val must be 'None' if the model does not contain site-level covariates.")
roxygen2::roxygenise()
roxygen2::roxygenise()
usethis::use_lifecycle()
data(gobyData)
data=gobyData
cov=c('Filter_time','Salinity')
family='poisson'
p10priors=c(1,20)
q=FALSE
phipriors=c(0.25,0.25)
multicore=TRUE
initial_values='None'
n.chain=4
n.iter.burn=500
n.iter.sample=2500
thin=1
adapt_delta=0.9
# make character inputs case-insensitive
#' @srrstats {G2.3b} Allow case-insensitive character parameter values
family <- tolower(family)
'%>%' <- magrittr::`%>%`
#convert qPCR data to long format
#' @srrstats {G2.7} Use as.data.frame() to allow input list of any tabular form (i.e., matrix, etc.)
qPCR_all <- as.data.frame(data$qPCR.N) %>%
dplyr::mutate(L=1:dim(data$qPCR.N)[1]) %>%
tidyr::pivot_longer(cols=!L,values_to='N') %>%
#' @srrstats {G2.15} Software does not assume non-missingness and actually expects it if the number of observations across sites is unequal
tidyr::drop_na()
qPCR.K_df <- as.data.frame(data$qPCR.K) %>%
dplyr::mutate(L=1:dim(data$qPCR.K)[1]) %>%
tidyr::pivot_longer(cols=!L,values_to='K') %>%
#' @srrstats {G2.15} Software does not assume non-missingness and actually expects it if the number of observations across sites is unequal
tidyr::drop_na()
qPCR_all$K <- qPCR.K_df$K
#convert count data to long format
#' @srrstats {G2.7} Use as.data.frame() to allow input list of any tabular form (i.e., matrix, etc.)
count_all <- as.data.frame(data$count) %>%
dplyr::mutate(L=1:dim(data$count)[1]) %>%
tidyr::pivot_longer(cols=!L,values_to='count') %>%
#' @srrstats {G2.15} Software does not assume non-missingness and actually expects it if the number of observations across sites is unequal
tidyr::drop_na()
#if q==TRUE, add count type data to count df
if(q==TRUE){
q_ref <- 1
#' @srrstats {G2.7} Use as.data.frame() to allow input list of any tabular form (i.e., matrix, etc.)
count.type_df <- as.data.frame(data$count.type) %>%
dplyr::mutate(L=1:dim(data$count.type)[1]) %>%
tidyr::pivot_longer(cols=!L,values_to='count.type') %>%
tidyr::drop_na()
count_all$count.type <- count.type_df$count.type
#create vector of q coefficient names
counttypes <- unique(count_all$count.type)
names <- counttypes[!counttypes==q_ref]
#' @srrstats {G2.4,G2.4c} Explicit conversion to character
q_names <- as.character(paste0('q_',names))
#add dummy variables for count type
for(i in seq_along(q_names)){
count_all[,q_names[i]] <- ifelse(count_all$count.type==names[i],1,0)
}
}
#if present, prepare covariate data
if(all(cov!='None')){
#' @srrstats {G2.7,G2.10} Use as.data.frame() to allow input list of any tabular form (i.e., matrix, etc.) and converts before filtering columns based on input 'cov'
site_mat <- as.data.frame(as.data.frame(data$site.cov)[,cov])
site_mat <- cbind(as.data.frame(rep(1,length(site_mat[,1]))),site_mat)
colnames(site_mat) <- c('int',cov)
}
#convert p10 prior
#p10 prior: convert beta(1,20) to lognormal distribution
#moment match from beta(alpha,beta) to normal(mu, sigma^2)
alpha <- p10priors[1]
beta <- p10priors[2]
mu <- alpha/(alpha+beta)
sigma_2 <- (alpha*beta)/((alpha+beta)^2*(alpha+beta+1))
#convert normal(mu, sigma^2) to lognormal(mu, sigma^2)
mu_ln <- log(mu^2/sqrt(mu^2+sigma_2))
sigma_2_ln <- log(1+sigma_2/mu^2)
sigma_ln <- sqrt(sigma_2_ln)
# create data that will be present in all model variations
data <- list(
S = nrow(qPCR_all),
L = qPCR_all$L,
Nloc = length(unique(qPCR_all$L)),
N = qPCR_all$N,
K = qPCR_all$K,
C = nrow(count_all),
R = count_all$L,
E = count_all$count,
p10priors = c(mu_ln,sigma_ln),
control = list(adapt_delta = adapt_delta)
)
# set up core number
if(multicore == TRUE){
cores <- parallel::detectCores()
} else {
cores <- 1
}
stan_model <- rstan::stan_model('inst/stan/joint_binary_cov_pois.stan')
##run model, no catchability, pois/gamma, covariates
model_index <- dplyr::case_when(family=='poisson'~ 1,
family=='gamma' ~ 2)
inits <- init_joint_cov(n.chain,count_all,cov,initial_values)
init_joint_cov <- function(n.chain,count_all,cov,initial_values){
#helper function
#joint model, catchability coefficient, site covariates
A <- list()
if(all(initial_values != 'None')){
for(i in 1:n.chain){
A[[i]] <- list(
if('mu' %in% names(initial_values[[i]])){
mu = inits[[i]]$mu
} else {
mu = stats::runif(length(unique(count_all$L)), 0.01, 5)
},
if('p10' %in% names(initial_values[[i]])){
p10 = inits[[i]]$p10
} else {
p10 = stats::runif(1,log(0.0001),log(0.08))
},
if('alpha' %in% names(initial_values[[i]])){
alpha = inits[[i]]$alpha
} else {
alpha = rep(0.1,length(cov)+1)
}
)
names(A[[i]]) <- c('mu','p10','alpha')
}
} else {
for(i in 1:n.chain){
A[[i]] <- list(
mu = stats::runif(length(unique(count_all$L)), 0.01, 5),
p10 = stats::runif(1,log(0.0001),log(0.08)),
alpha = rep(0.1,length(cov)+1)
)
}
}
return(A)
}
out <- rstan::sampling(c(stanmodels$joint_binary_cov_pois,
stanmodels$joint_binary_cov_gamma)[model_index][[1]],
data = rlist::list.append(
data,
nsitecov = length(cov)+1,
mat_site = as.matrix(site_mat)
),
cores = cores,
#' @srrstats {G2.4,G2.4a} explicit conversion to integers for sampling arguments
chains = as.integer(n.chain),
thin = as.integer(thin),
warmup = as.integer(n.iter.burn),
iter = as.integer(n.iter.burn) + as.integer(n.iter.sample),
init = inits
)
inits <- init_joint_cov(n.chain,count_all,cov,initial_values)
out <- rstan::sampling(stan_model,
data = rlist::list.append(
data,
nsitecov = length(cov)+1,
mat_site = as.matrix(site_mat)
),
cores = cores,
#' @srrstats {G2.4,G2.4a} explicit conversion to integers for sampling arguments
chains = as.integer(n.chain),
thin = as.integer(thin),
warmup = as.integer(n.iter.burn),
iter = as.integer(n.iter.burn) + as.integer(n.iter.sample),
init = inits,
verbose = FALSE
)
out <- rstan::sampling(stan_model,
data = rlist::list.append(
data,
nsitecov = length(cov)+1,
mat_site = as.matrix(site_mat)
),
cores = cores,
#' @srrstats {G2.4,G2.4a} explicit conversion to integers for sampling arguments
chains = as.integer(n.chain),
thin = as.integer(thin),
warmup = as.integer(n.iter.burn),
iter = as.integer(n.iter.burn) + as.integer(n.iter.sample),
init = inits,
verbose = FALSE,
refresh = 3000
)
n.iter.burn
n.iter.sample
out <- rstan::sampling(stan_model,
data = rlist::list.append(
data,
nsitecov = length(cov)+1,
mat_site = as.matrix(site_mat)
),
cores = cores,
#' @srrstats {G2.4,G2.4a} explicit conversion to integers for sampling arguments
chains = as.integer(n.chain),
thin = as.integer(thin),
warmup = as.integer(n.iter.burn),
iter = as.integer(n.iter.burn) + as.integer(n.iter.sample),
init = inits,
verbose = FALSE
)
roxygen2::roxygenise()
out <- rstan::sampling(stan_model,
data = rlist::list.append(
data,
nsitecov = length(cov)+1,
mat_site = as.matrix(site_mat)
),
cores = cores,
#' @srrstats {G2.4,G2.4a} explicit conversion to integers for sampling arguments
chains = as.integer(n.chain),
thin = as.integer(thin),
warmup = as.integer(n.iter.burn),
iter = as.integer(n.iter.burn) + as.integer(n.iter.sample),
init = inits,
refresh = 0
)
verbose <- TRUE
out <- rstan::sampling(stan_model,
data = rlist::list.append(
data,
nsitecov = length(cov)+1,
mat_site = as.matrix(site_mat)
),
cores = cores,
#' @srrstats {G2.4,G2.4a} explicit conversion to integers for sampling arguments
chains = as.integer(n.chain),
thin = as.integer(thin),
warmup = as.integer(n.iter.burn),
iter = as.integer(n.iter.burn) + as.integer(n.iter.sample),
init = inits,
refresh = ifelse(verbose=TRUE,500,0)
)
ifelse(verbose=TRUE,500,0)
ifelse(verbose==TRUE,500,0)
out <- rstan::sampling(stan_model,
data = rlist::list.append(
data,
nsitecov = length(cov)+1,
mat_site = as.matrix(site_mat)
),
cores = cores,
#' @srrstats {G2.4,G2.4a} explicit conversion to integers for sampling arguments
chains = as.integer(n.chain),
thin = as.integer(thin),
warmup = as.integer(n.iter.burn),
iter = as.integer(n.iter.burn) + as.integer(n.iter.sample),
init = inits,
refresh = ifelse(verbose==TRUE,500,0)
)
roxygen2::roxygenise()
62/(62+59)
63/(63+58)
65/(65+56)
66/(66+55)
61/(61/44)
61/(61+44)
devtools::install()
devtools::install()
pkgbuild::check_build_tools(debug = TRUE)
devtools::install()
data(gobyData)
stan_model <- rstan::stan_model('inst/stan/joint_binary_cov_pois.stan')
cov=c('Filter_time','Salinity')
family='poisson'
p10priors=c(1,20)
q=FALSE
phipriors=c(0.25,0.25)
multicore=TRUE
initial_values='None'
n.chain=4
n.iter.burn=500
n.iter.sample=2500
thin=1
adapt_delta=0.9
verbose=TRUE
# make character inputs case-insensitive
#' @srrstats {G2.3b} Allow case-insensitive character parameter values
family <- tolower(family)
'%>%' <- magrittr::`%>%`
#convert qPCR data to long format
#' @srrstats {G2.7} Use as.data.frame() to allow input list of any tabular form (i.e., matrix, etc.)
qPCR_all <- as.data.frame(data$qPCR.N) %>%
dplyr::mutate(L=1:dim(data$qPCR.N)[1]) %>%
tidyr::pivot_longer(cols=!L,values_to='N') %>%
#' @srrstats {G2.15} Software does not assume non-missingness and actually expects it if the number of observations across sites is unequal
tidyr::drop_na()
qPCR.K_df <- as.data.frame(data$qPCR.K) %>%
dplyr::mutate(L=1:dim(data$qPCR.K)[1]) %>%
tidyr::pivot_longer(cols=!L,values_to='K') %>%
#' @srrstats {G2.15} Software does not assume non-missingness and actually expects it if the number of observations across sites is unequal
tidyr::drop_na()
qPCR_all$K <- qPCR.K_df$K
data <- gobyData
#convert qPCR data to long format
#' @srrstats {G2.7} Use as.data.frame() to allow input list of any tabular form (i.e., matrix, etc.)
qPCR_all <- as.data.frame(data$qPCR.N) %>%
dplyr::mutate(L=1:dim(data$qPCR.N)[1]) %>%
tidyr::pivot_longer(cols=!L,values_to='N') %>%
#' @srrstats {G2.15} Software does not assume non-missingness and actually expects it if the number of observations across sites is unequal
tidyr::drop_na()
qPCR.K_df <- as.data.frame(data$qPCR.K) %>%
dplyr::mutate(L=1:dim(data$qPCR.K)[1]) %>%
tidyr::pivot_longer(cols=!L,values_to='K') %>%
#' @srrstats {G2.15} Software does not assume non-missingness and actually expects it if the number of observations across sites is unequal
tidyr::drop_na()
qPCR_all$K <- qPCR.K_df$K
#convert count data to long format
#' @srrstats {G2.7} Use as.data.frame() to allow input list of any tabular form (i.e., matrix, etc.)
count_all <- as.data.frame(data$count) %>%
dplyr::mutate(L=1:dim(data$count)[1]) %>%
tidyr::pivot_longer(cols=!L,values_to='count') %>%
#' @srrstats {G2.15} Software does not assume non-missingness and actually expects it if the number of observations across sites is unequal
tidyr::drop_na()
#if q==TRUE, add count type data to count df
if(q==TRUE){
q_ref <- 1
#' @srrstats {G2.7} Use as.data.frame() to allow input list of any tabular form (i.e., matrix, etc.)
count.type_df <- as.data.frame(data$count.type) %>%
dplyr::mutate(L=1:dim(data$count.type)[1]) %>%
tidyr::pivot_longer(cols=!L,values_to='count.type') %>%
tidyr::drop_na()
count_all$count.type <- count.type_df$count.type
#create vector of q coefficient names
counttypes <- unique(count_all$count.type)
names <- counttypes[!counttypes==q_ref]
#' @srrstats {G2.4,G2.4c} Explicit conversion to character
q_names <- as.character(paste0('q_',names))
#add dummy variables for count type
for(i in seq_along(q_names)){
count_all[,q_names[i]] <- ifelse(count_all$count.type==names[i],1,0)
}
}
#if present, prepare covariate data
if(all(cov!='None')){
#' @srrstats {G2.7,G2.10} Use as.data.frame() to allow input list of any tabular form (i.e., matrix, etc.) and converts before filtering columns based on input 'cov'
site_mat <- as.data.frame(as.data.frame(data$site.cov)[,cov])
site_mat <- cbind(as.data.frame(rep(1,length(site_mat[,1]))),site_mat)
colnames(site_mat) <- c('int',cov)
}
#convert p10 prior
#p10 prior: convert beta(1,20) to lognormal distribution
#moment match from beta(alpha,beta) to normal(mu, sigma^2)
alpha <- p10priors[1]
beta <- p10priors[2]
mu <- alpha/(alpha+beta)
sigma_2 <- (alpha*beta)/((alpha+beta)^2*(alpha+beta+1))
#convert normal(mu, sigma^2) to lognormal(mu, sigma^2)
mu_ln <- log(mu^2/sqrt(mu^2+sigma_2))
sigma_2_ln <- log(1+sigma_2/mu^2)
sigma_ln <- sqrt(sigma_2_ln)
# create data that will be present in all model variations
data <- list(
S = nrow(qPCR_all),
L = qPCR_all$L,
Nloc = length(unique(qPCR_all$L)),
N = qPCR_all$N,
K = qPCR_all$K,
C = nrow(count_all),
R = count_all$L,
E = count_all$count,
p10priors = c(mu_ln,sigma_ln),
control = list(adapt_delta = adapt_delta)
)
# set up core number
if(multicore == TRUE){
cores <- parallel::detectCores()
} else {
cores <- 1
}
init_joint_cov <- function(n.chain,count_all,cov,initial_values){
#helper function
#joint model, catchability coefficient, site covariates
A <- list()
if(all(initial_values != 'None')){
for(i in 1:n.chain){
A[[i]] <- list(
if('mu' %in% names(initial_values[[i]])){
mu = inits[[i]]$mu
} else {
mu = stats::runif(length(unique(count_all$L)), 0.01, 5)
},
if('p10' %in% names(initial_values[[i]])){
p10 = inits[[i]]$p10
} else {
p10 = stats::runif(1,log(0.0001),log(0.08))
},
if('alpha' %in% names(initial_values[[i]])){
alpha = inits[[i]]$alpha
} else {
alpha = rep(0.1,length(cov)+1)
}
)
names(A[[i]]) <- c('mu','p10','alpha')
}
} else {
for(i in 1:n.chain){
A[[i]] <- list(
mu = stats::runif(length(unique(count_all$L)), 0.01, 5),
p10 = stats::runif(1,log(0.0001),log(0.08)),
alpha = rep(0.1,length(cov)+1)
)
}
}
return(A)
}
##run model, no catchability, negbin, covariates
inits <- init_joint_cov(n.chain,count_all,cov,initial_values)
out <- rstan::sampling(#c(stanmodels$joint_binary_cov_pois,
# stanmodels$joint_binary_cov_gamma)[model_index][[1]],
stan_model,
data = rlist::list.append(
data,
nsitecov = length(cov)+1,
mat_site = as.matrix(site_mat)
),
cores = cores,
#' @srrstats {G2.4,G2.4a} explicit conversion to integers for sampling arguments
chains = as.integer(n.chain),
thin = as.integer(thin),
warmup = as.integer(n.iter.burn),
iter = as.integer(n.iter.burn) + as.integer(n.iter.sample),
init = inits,
refresh = 1#ifelse(verbose==TRUE,500,0)
)
out
devtools::install()
devtools::install()
