data <- readRDS('../neha_data.rds')
# initial values should be a list of named lists
inits <- list()
for(i in 1:n.chain){
inits[[i]] <- list(
mu_trad = rowMeans(data$count,na.rm=TRUE)
)
}
cov = NULL
family = 'poisson'
p10priors = c(1,200)
q = FALSE
phipriors = NULL
multicore = TRUE
initial_values = NULL
n.chain = 4
n.iter.burn = 10000
n.iter.sample = 2500
thin = 1
adapt_delta = 0.99
verbose = TRUE
seed = NULL
###
#convert data to long format
'%>%' <- magrittr::`%>%`
# convert qPCR data to long format
#' @srrstats {G2.7} Use as.data.frame() to allow input list of any tabular
#'   form (i.e., matrix, etc.)
qPCR_all <- as.data.frame(data$qPCR.N) %>%
dplyr::mutate(L = 1:dim(data$qPCR.N)[1]) %>%
tidyr::pivot_longer(cols =! L,values_to = 'N') %>%
#' @srrstats {G2.15} Software does not assume non-missingness and actually
#'   expects it if the number of observations across sites is unequal
tidyr::drop_na()
qPCR.K_df <- as.data.frame(data$qPCR.K) %>%
dplyr::mutate(L = 1:dim(data$qPCR.K)[1]) %>%
tidyr::pivot_longer(cols =! L,values_to = 'K') %>%
#' @srrstats {G2.15} Software does not assume non-missingness and actually
#'   expects it if the number of observations across sites is unequal
tidyr::drop_na()
qPCR_all$K <- qPCR.K_df$K
# convert count data to long format
#' @srrstats {G2.7} Use as.data.frame() to allow input list of any tabular
#'   form (i.e., matrix, etc.)
count_all <- as.data.frame(data$count) %>%
dplyr::mutate(L = 1:dim(data$count)[1]) %>%
tidyr::pivot_longer(cols =! L,values_to = 'count') %>%
#' @srrstats {G2.15} Software does not assume non-missingness and actually
#' expects it if the number of observations across sites is unequal
tidyr::drop_na()
# subset count data to remove sites without traditional samples
count_df <- as.data.frame(data$count)
sub_count <- count_df[rowSums(is.na(count_df)) != ncol(count_df), ]
# add site index to count data
index_match <- as.data.frame(cbind(unique(count_all$L),
1:dim(sub_count)[1]))
colnames(index_match) <- c('L','R')
count_all <- dplyr::left_join(count_all,index_match,by='L')
# get site indices with paired and unpaired dna samples
trad_ind <- index_match$L
dna_ind <- unique(qPCR_all$L)[!unique(qPCR_all$L)%in% trad_ind]
# subset qPCR data -- paired
qPCR_all_trad <- qPCR_all[qPCR_all$L %in% trad_ind,]
L_match_trad <- as.data.frame(cbind(unique(qPCR_all_trad$L),
1:length(unique(qPCR_all_trad$L))))
colnames(L_match_trad) <- c('L','L_unique')
qPCR_all_trad <- dplyr::left_join(qPCR_all_trad,L_match_trad,by='L')
# subset qPCR data -- unpaired
if(length(dna_ind)>0){
qPCR_all_dna <- qPCR_all[qPCR_all$L %in% dna_ind,]
L_match_dna <- as.data.frame(cbind(unique(qPCR_all_dna$L),
1:length(unique(qPCR_all_dna$L))))
colnames(L_match_dna) <- c('L','L_unique')
qPCR_all_dna <- dplyr::left_join(qPCR_all_dna,L_match_dna,by='L')
} else {
qPCR_all_dna <- as.data.frame(matrix(NA,nrow=0,ncol=4))
colnames(qPCR_all_dna) <- c('L','N','K','L_unique')
}
# convert p10 prior
# p10 prior: convert beta(1,20) to lognormal distribution
# moment match from beta(alpha,beta) to normal(mu, sigma^2)
alpha <- p10priors[1]
beta <- p10priors[2]
mu <- alpha/(alpha+beta)
sigma_2 <- (alpha*beta)/((alpha+beta)^2*(alpha+beta+1))
# convert normal(mu, sigma^2) to lognormal(mu, sigma^2)
mu_ln <- log(mu^2/sqrt(mu^2+sigma_2))
sigma_2_ln <- log(1+sigma_2/mu^2)
sigma_ln <- sqrt(sigma_2_ln)
# create data that will be present in all model variations
data <- list(
S = nrow(qPCR_all_trad),
S_dna = nrow(qPCR_all_dna),
C = nrow(count_all),
L = qPCR_all_trad$L_unique,
L_dna = qPCR_all_dna$L_unique,
R = count_all$R,
Nloc_dna = length(unique(qPCR_all_dna$L)),
Nloc_trad = length(unique(qPCR_all_trad$L)),
trad_ind = trad_ind,
dna_ind = as.array(dna_ind),
E = count_all$count,
N = qPCR_all_trad$N,
K = qPCR_all_trad$K,
N_dna = qPCR_all_dna$N,
K_dna = qPCR_all_dna$K,
p10priors = c(mu_ln,sigma_ln),
control = list(adapt_delta = adapt_delta)
)
# run model
out <- rstan::sampling(model,
data = data,
cores = 4,
#' @srrstats {G2.4,G2.4a} explicit conversion to
#'   integers for sampling arguments
chains = as.integer(n.chain),
thin = as.integer(thin),
warmup = as.integer(n.iter.burn),
iter = (
as.integer(n.iter.burn) + as.integer(n.iter.sample)
),
init = inits,
refresh = ifelse(verbose == TRUE,500,0)
)
inits
# initial values should be a list of named lists
inits <- list()
for(i in 1:n.chain){
inits[[i]] <- list(
mu_trad = rowMeans(data$count,na.rm=TRUE),
log_p10 = -5,
beta = 1.5
)
}
data <- readRDS('../neha_data.rds')
# initial values should be a list of named lists
inits <- list()
for(i in 1:n.chain){
inits[[i]] <- list(
mu_trad = rowMeans(data$count,na.rm=TRUE),
log_p10 = -5,
beta = 1.5
)
}
cov = NULL
family = 'poisson'
p10priors = c(1,200)
q = FALSE
phipriors = NULL
multicore = TRUE
initial_values = NULL
n.chain = 4
n.iter.burn = 10000
n.iter.sample = 2500
thin = 1
adapt_delta = 0.99
verbose = TRUE
seed = NULL
###
#convert data to long format
'%>%' <- magrittr::`%>%`
# convert qPCR data to long format
#' @srrstats {G2.7} Use as.data.frame() to allow input list of any tabular
#'   form (i.e., matrix, etc.)
qPCR_all <- as.data.frame(data$qPCR.N) %>%
dplyr::mutate(L = 1:dim(data$qPCR.N)[1]) %>%
tidyr::pivot_longer(cols =! L,values_to = 'N') %>%
#' @srrstats {G2.15} Software does not assume non-missingness and actually
#'   expects it if the number of observations across sites is unequal
tidyr::drop_na()
qPCR.K_df <- as.data.frame(data$qPCR.K) %>%
dplyr::mutate(L = 1:dim(data$qPCR.K)[1]) %>%
tidyr::pivot_longer(cols =! L,values_to = 'K') %>%
#' @srrstats {G2.15} Software does not assume non-missingness and actually
#'   expects it if the number of observations across sites is unequal
tidyr::drop_na()
qPCR_all$K <- qPCR.K_df$K
# convert count data to long format
#' @srrstats {G2.7} Use as.data.frame() to allow input list of any tabular
#'   form (i.e., matrix, etc.)
count_all <- as.data.frame(data$count) %>%
dplyr::mutate(L = 1:dim(data$count)[1]) %>%
tidyr::pivot_longer(cols =! L,values_to = 'count') %>%
#' @srrstats {G2.15} Software does not assume non-missingness and actually
#' expects it if the number of observations across sites is unequal
tidyr::drop_na()
# subset count data to remove sites without traditional samples
count_df <- as.data.frame(data$count)
sub_count <- count_df[rowSums(is.na(count_df)) != ncol(count_df), ]
# add site index to count data
index_match <- as.data.frame(cbind(unique(count_all$L),
1:dim(sub_count)[1]))
colnames(index_match) <- c('L','R')
count_all <- dplyr::left_join(count_all,index_match,by='L')
# get site indices with paired and unpaired dna samples
trad_ind <- index_match$L
dna_ind <- unique(qPCR_all$L)[!unique(qPCR_all$L)%in% trad_ind]
# subset qPCR data -- paired
qPCR_all_trad <- qPCR_all[qPCR_all$L %in% trad_ind,]
L_match_trad <- as.data.frame(cbind(unique(qPCR_all_trad$L),
1:length(unique(qPCR_all_trad$L))))
colnames(L_match_trad) <- c('L','L_unique')
qPCR_all_trad <- dplyr::left_join(qPCR_all_trad,L_match_trad,by='L')
# subset qPCR data -- unpaired
if(length(dna_ind)>0){
qPCR_all_dna <- qPCR_all[qPCR_all$L %in% dna_ind,]
L_match_dna <- as.data.frame(cbind(unique(qPCR_all_dna$L),
1:length(unique(qPCR_all_dna$L))))
colnames(L_match_dna) <- c('L','L_unique')
qPCR_all_dna <- dplyr::left_join(qPCR_all_dna,L_match_dna,by='L')
} else {
qPCR_all_dna <- as.data.frame(matrix(NA,nrow=0,ncol=4))
colnames(qPCR_all_dna) <- c('L','N','K','L_unique')
}
# convert p10 prior
# p10 prior: convert beta(1,20) to lognormal distribution
# moment match from beta(alpha,beta) to normal(mu, sigma^2)
alpha <- p10priors[1]
beta <- p10priors[2]
mu <- alpha/(alpha+beta)
sigma_2 <- (alpha*beta)/((alpha+beta)^2*(alpha+beta+1))
# convert normal(mu, sigma^2) to lognormal(mu, sigma^2)
mu_ln <- log(mu^2/sqrt(mu^2+sigma_2))
sigma_2_ln <- log(1+sigma_2/mu^2)
sigma_ln <- sqrt(sigma_2_ln)
# create data that will be present in all model variations
data <- list(
S = nrow(qPCR_all_trad),
S_dna = nrow(qPCR_all_dna),
C = nrow(count_all),
L = qPCR_all_trad$L_unique,
L_dna = qPCR_all_dna$L_unique,
R = count_all$R,
Nloc_dna = length(unique(qPCR_all_dna$L)),
Nloc_trad = length(unique(qPCR_all_trad$L)),
trad_ind = trad_ind,
dna_ind = as.array(dna_ind),
E = count_all$count,
N = qPCR_all_trad$N,
K = qPCR_all_trad$K,
N_dna = qPCR_all_dna$N,
K_dna = qPCR_all_dna$K,
p10priors = c(mu_ln,sigma_ln),
control = list(adapt_delta = adapt_delta)
)
# run model
out <- rstan::sampling(model,
data = data,
cores = 4,
#' @srrstats {G2.4,G2.4a} explicit conversion to
#'   integers for sampling arguments
chains = as.integer(n.chain),
thin = as.integer(thin),
warmup = as.integer(n.iter.burn),
iter = (
as.integer(n.iter.burn) + as.integer(n.iter.sample)
),
init = inits,
refresh = ifelse(verbose == TRUE,500,0)
)
data <- readRDS('../neha_data.rds')
# initial values should be a list of named lists
inits <- list()
for(i in 1:n.chain){
inits[[i]] <- list(
mu_trad = rowMeans(data$count,na.rm=TRUE),
log_p10 = -5,
beta = 1.5
)
}
cov = NULL
family = 'poisson'
p10priors = c(1,200)
q = FALSE
phipriors = NULL
multicore = TRUE
initial_values = NULL
n.chain = 4
n.iter.burn = 10000
n.iter.sample = 2500
thin = 1
adapt_delta = 0.99
verbose = TRUE
seed = NULL
###
#convert data to long format
'%>%' <- magrittr::`%>%`
# convert qPCR data to long format
#' @srrstats {G2.7} Use as.data.frame() to allow input list of any tabular
#'   form (i.e., matrix, etc.)
qPCR_all <- as.data.frame(data$qPCR.N) %>%
dplyr::mutate(L = 1:dim(data$qPCR.N)[1]) %>%
tidyr::pivot_longer(cols =! L,values_to = 'N') %>%
#' @srrstats {G2.15} Software does not assume non-missingness and actually
#'   expects it if the number of observations across sites is unequal
tidyr::drop_na()
qPCR.K_df <- as.data.frame(data$qPCR.K) %>%
dplyr::mutate(L = 1:dim(data$qPCR.K)[1]) %>%
tidyr::pivot_longer(cols =! L,values_to = 'K') %>%
#' @srrstats {G2.15} Software does not assume non-missingness and actually
#'   expects it if the number of observations across sites is unequal
tidyr::drop_na()
qPCR_all$K <- qPCR.K_df$K
# convert count data to long format
#' @srrstats {G2.7} Use as.data.frame() to allow input list of any tabular
#'   form (i.e., matrix, etc.)
count_all <- as.data.frame(data$count) %>%
dplyr::mutate(L = 1:dim(data$count)[1]) %>%
tidyr::pivot_longer(cols =! L,values_to = 'count') %>%
#' @srrstats {G2.15} Software does not assume non-missingness and actually
#' expects it if the number of observations across sites is unequal
tidyr::drop_na()
# subset count data to remove sites without traditional samples
count_df <- as.data.frame(data$count)
sub_count <- count_df[rowSums(is.na(count_df)) != ncol(count_df), ]
# add site index to count data
index_match <- as.data.frame(cbind(unique(count_all$L),
1:dim(sub_count)[1]))
colnames(index_match) <- c('L','R')
count_all <- dplyr::left_join(count_all,index_match,by='L')
# get site indices with paired and unpaired dna samples
trad_ind <- index_match$L
dna_ind <- unique(qPCR_all$L)[!unique(qPCR_all$L)%in% trad_ind]
# subset qPCR data -- paired
qPCR_all_trad <- qPCR_all[qPCR_all$L %in% trad_ind,]
L_match_trad <- as.data.frame(cbind(unique(qPCR_all_trad$L),
1:length(unique(qPCR_all_trad$L))))
colnames(L_match_trad) <- c('L','L_unique')
qPCR_all_trad <- dplyr::left_join(qPCR_all_trad,L_match_trad,by='L')
# subset qPCR data -- unpaired
if(length(dna_ind)>0){
qPCR_all_dna <- qPCR_all[qPCR_all$L %in% dna_ind,]
L_match_dna <- as.data.frame(cbind(unique(qPCR_all_dna$L),
1:length(unique(qPCR_all_dna$L))))
colnames(L_match_dna) <- c('L','L_unique')
qPCR_all_dna <- dplyr::left_join(qPCR_all_dna,L_match_dna,by='L')
} else {
qPCR_all_dna <- as.data.frame(matrix(NA,nrow=0,ncol=4))
colnames(qPCR_all_dna) <- c('L','N','K','L_unique')
}
# convert p10 prior
# p10 prior: convert beta(1,20) to lognormal distribution
# moment match from beta(alpha,beta) to normal(mu, sigma^2)
alpha <- p10priors[1]
beta <- p10priors[2]
mu <- alpha/(alpha+beta)
sigma_2 <- (alpha*beta)/((alpha+beta)^2*(alpha+beta+1))
# convert normal(mu, sigma^2) to lognormal(mu, sigma^2)
mu_ln <- log(mu^2/sqrt(mu^2+sigma_2))
sigma_2_ln <- log(1+sigma_2/mu^2)
sigma_ln <- sqrt(sigma_2_ln)
# create data that will be present in all model variations
data <- list(
S = nrow(qPCR_all_trad),
S_dna = nrow(qPCR_all_dna),
C = nrow(count_all),
L = qPCR_all_trad$L_unique,
L_dna = qPCR_all_dna$L_unique,
R = count_all$R,
Nloc_dna = length(unique(qPCR_all_dna$L)),
Nloc_trad = length(unique(qPCR_all_trad$L)),
trad_ind = trad_ind,
dna_ind = as.array(dna_ind),
E = count_all$count,
N = qPCR_all_trad$N,
K = qPCR_all_trad$K,
N_dna = qPCR_all_dna$N,
K_dna = qPCR_all_dna$K,
p10priors = c(mu_ln,sigma_ln),
control = list(adapt_delta = adapt_delta)
)
# run model
out <- rstan::sampling(model,
data = data,
cores = 4,
#' @srrstats {G2.4,G2.4a} explicit conversion to
#'   integers for sampling arguments
chains = as.integer(n.chain),
thin = as.integer(thin),
warmup = as.integer(n.iter.burn),
iter = (
as.integer(n.iter.burn) + as.integer(n.iter.sample)
),
init = inits,
refresh = ifelse(verbose == TRUE,500,0)
)
data <- readRDS('../neha_data.rds')
# initial values should be a list of named lists
inits <- list()
for(i in 1:n.chain){
inits[[i]] <- list(
mu_trad = rowMeans(data$count,na.rm=TRUE),
log_p10 = -5,
beta = 1.5
)
}
cov = NULL
family = 'poisson'
p10priors = c(1,250)
q = FALSE
phipriors = NULL
multicore = TRUE
initial_values = NULL
n.chain = 4
n.iter.burn = 10000
n.iter.sample = 2500
thin = 1
adapt_delta = 0.99
verbose = TRUE
seed = NULL
###
#convert data to long format
'%>%' <- magrittr::`%>%`
# convert qPCR data to long format
#' @srrstats {G2.7} Use as.data.frame() to allow input list of any tabular
#'   form (i.e., matrix, etc.)
qPCR_all <- as.data.frame(data$qPCR.N) %>%
dplyr::mutate(L = 1:dim(data$qPCR.N)[1]) %>%
tidyr::pivot_longer(cols =! L,values_to = 'N') %>%
#' @srrstats {G2.15} Software does not assume non-missingness and actually
#'   expects it if the number of observations across sites is unequal
tidyr::drop_na()
qPCR.K_df <- as.data.frame(data$qPCR.K) %>%
dplyr::mutate(L = 1:dim(data$qPCR.K)[1]) %>%
tidyr::pivot_longer(cols =! L,values_to = 'K') %>%
#' @srrstats {G2.15} Software does not assume non-missingness and actually
#'   expects it if the number of observations across sites is unequal
tidyr::drop_na()
qPCR_all$K <- qPCR.K_df$K
# convert count data to long format
#' @srrstats {G2.7} Use as.data.frame() to allow input list of any tabular
#'   form (i.e., matrix, etc.)
count_all <- as.data.frame(data$count) %>%
dplyr::mutate(L = 1:dim(data$count)[1]) %>%
tidyr::pivot_longer(cols =! L,values_to = 'count') %>%
#' @srrstats {G2.15} Software does not assume non-missingness and actually
#' expects it if the number of observations across sites is unequal
tidyr::drop_na()
# subset count data to remove sites without traditional samples
count_df <- as.data.frame(data$count)
sub_count <- count_df[rowSums(is.na(count_df)) != ncol(count_df), ]
# add site index to count data
index_match <- as.data.frame(cbind(unique(count_all$L),
1:dim(sub_count)[1]))
colnames(index_match) <- c('L','R')
count_all <- dplyr::left_join(count_all,index_match,by='L')
# get site indices with paired and unpaired dna samples
trad_ind <- index_match$L
dna_ind <- unique(qPCR_all$L)[!unique(qPCR_all$L)%in% trad_ind]
# subset qPCR data -- paired
qPCR_all_trad <- qPCR_all[qPCR_all$L %in% trad_ind,]
L_match_trad <- as.data.frame(cbind(unique(qPCR_all_trad$L),
1:length(unique(qPCR_all_trad$L))))
colnames(L_match_trad) <- c('L','L_unique')
qPCR_all_trad <- dplyr::left_join(qPCR_all_trad,L_match_trad,by='L')
# subset qPCR data -- unpaired
if(length(dna_ind)>0){
qPCR_all_dna <- qPCR_all[qPCR_all$L %in% dna_ind,]
L_match_dna <- as.data.frame(cbind(unique(qPCR_all_dna$L),
1:length(unique(qPCR_all_dna$L))))
colnames(L_match_dna) <- c('L','L_unique')
qPCR_all_dna <- dplyr::left_join(qPCR_all_dna,L_match_dna,by='L')
} else {
qPCR_all_dna <- as.data.frame(matrix(NA,nrow=0,ncol=4))
colnames(qPCR_all_dna) <- c('L','N','K','L_unique')
}
# convert p10 prior
# p10 prior: convert beta(1,20) to lognormal distribution
# moment match from beta(alpha,beta) to normal(mu, sigma^2)
alpha <- p10priors[1]
beta <- p10priors[2]
mu <- alpha/(alpha+beta)
sigma_2 <- (alpha*beta)/((alpha+beta)^2*(alpha+beta+1))
# convert normal(mu, sigma^2) to lognormal(mu, sigma^2)
mu_ln <- log(mu^2/sqrt(mu^2+sigma_2))
sigma_2_ln <- log(1+sigma_2/mu^2)
sigma_ln <- sqrt(sigma_2_ln)
# create data that will be present in all model variations
data <- list(
S = nrow(qPCR_all_trad),
S_dna = nrow(qPCR_all_dna),
C = nrow(count_all),
L = qPCR_all_trad$L_unique,
L_dna = qPCR_all_dna$L_unique,
R = count_all$R,
Nloc_dna = length(unique(qPCR_all_dna$L)),
Nloc_trad = length(unique(qPCR_all_trad$L)),
trad_ind = trad_ind,
dna_ind = as.array(dna_ind),
E = count_all$count,
N = qPCR_all_trad$N,
K = qPCR_all_trad$K,
N_dna = qPCR_all_dna$N,
K_dna = qPCR_all_dna$K,
p10priors = c(mu_ln,sigma_ln),
control = list(adapt_delta = adapt_delta)
)
# run model
out <- rstan::sampling(model,
data = data,
cores = 4,
#' @srrstats {G2.4,G2.4a} explicit conversion to
#'   integers for sampling arguments
chains = as.integer(n.chain),
thin = as.integer(thin),
warmup = as.integer(n.iter.burn),
iter = (
as.integer(n.iter.burn) + as.integer(n.iter.sample)
),
init = inits,
refresh = ifelse(verbose == TRUE,500,0)
)
