mod <- stan_model('inst/stan/joint_cov_pois.stan')
pkgbuild::clean_dll()
pkgbuild::compile_dll()
devtools::load_all()
data(gre)
data("greencrabData")
fit.q <- jointModel(data=greencrabData,cov='None',family='negbin',p10priors=c(1,20),q=TRUE)
summarize(fit.q)
summarize(fit.q,par='mu')
modelfit <- fit.q
cov.val <- 'None'
if(all(cov.val=='None')){
#extract posteriors for beta and p10 parameters
##beta
posterior_beta <- unlist(rstan::extract(modelfit, pars = "beta"))
#p10
posterior_p10 <- unlist(rstan::extract(modelfit, pars = "p10"))
} else {
#extract posteriors for beta and p10 parameters
##alpha
posterior_alpha <- rstan::extract(modelfit, pars = "alpha")$alpha
##beta
posterior_beta <- posterior_alpha %*% c(1,cov.val)
#p10
posterior_p10 <- unlist(rstan::extract(modelfit, pars = "p10"))
}
#calculate mu_critical -- gear type 1
critical_mu_1 <- rep(NA, length(posterior_beta))
for(i in 1:length(critical_mu_1)){
critical_mu_1[i] <- posterior_p10[i]*exp(posterior_beta[i])/(1-posterior_p10[i])
}
modelfit@par_dims
modelfit@par_dims$q
i <- 1
paste0('critical_mu_',i)
assign(paste("critical_mu_", "i+1", sep=""),rep(NA, length(posterior_beta)))
assign(paste("critical_mu_", i+1, sep=""),rep(NA, length(posterior_beta)))
#extract q values
posterior_q <- rstan::extract(modelfit, pars = "q")$q
posterior_q
for(i in 1:modelfit@par_dims$q){
assign(paste("critical_mu_", i+1, sep=""),critical_mu_1*posterior_q[,i])
}
critical_mu_2
out <- list(median=stats::median(critical_mu),
lower_ci=bayestestR::ci(critical_mu, method = 'HDI', ci = ci)[2],
upper_ci=bayestestR::ci(critical_mu, method = 'HDI', ci = ci)[3])
out <- list(median=stats::median(critical_mu_1),
lower_ci=bayestestR::ci(critical_mu_1, method = 'HDI', ci = ci)[2],
upper_ci=bayestestR::ci(critical_mu_1, method = 'HDI', ci = ci)[3])
ci <- 0.9
out <- list(median=stats::median(critical_mu_1),
lower_ci=bayestestR::ci(critical_mu_1, method = 'HDI', ci = ci)[2],
upper_ci=bayestestR::ci(critical_mu_1, method = 'HDI', ci = ci)[3])
out
assign(paste('out',i+1, sep=""),list(median=stats::median(paste0('critical_mu_',i+1)),
lower_ci=bayestestR::ci(paste0('critical_mu_',i+1), method = 'HDI', ci = ci)[2],
upper_ci=bayestestR::ci(paste0('critical_mu_',i+1), method = 'HDI', ci = ci)[3]))
paste0('critical_mu_',i+1)
stats::median(paste0('critical_mu_',i+1))
out1
out1 <- list(median=stats::median(critical_mu_1),
lower_ci=bayestestR::ci(critical_mu_1, method = 'HDI', ci = ci)[2],
upper_ci=bayestestR::ci(critical_mu_1, method = 'HDI', ci = ci)[3])
out1
assign(paste("median", i+1, sep=""),stats::mediancritical_mu_1*posterior_q[,i]))
assign(paste("median", i+1, sep=""),stats::median(critical_mu_1*posterior_q[,i]))
median_2
assign(paste("median_", i+1, sep=""),stats::median(critical_mu_1*posterior_q[,i]))
assign(paste("lower_ci_", i+1, sep=""),bayestestR::ci(critical_mu_1*posterior_q[,i], method = 'HDI', ci = ci)[2])
assign(paste("upper_ci_", i+1, sep=""),bayestestR::ci(critical_mu_1*posterior_q[,i], method = 'HDI', ci = ci)[3])
bayestestR::ci(critical_mu_1*posterior_q[,i], method = 'HDI', ci = ci)[2]
list(assign(paste("median_", i+1, sep=""),stats::median(critical_mu_1*posterior_q[,i])),
assign(paste("lower_ci_", i+1, sep=""),bayestestR::ci(critical_mu_1*posterior_q[,i], method = 'HDI', ci = ci)[2]),
assign(paste("upper_ci_", i+1, sep=""),bayestestR::ci(critical_mu_1*posterior_q[,i], method = 'HDI', ci = ci)[3]))
list(paste("median_", i+1, sep=""),stats::median(critical_mu_1*posterior_q[,i]),
paste("lower_ci_", i+1, sep=""),bayestestR::ci(critical_mu_1*posterior_q[,i], method = 'HDI', ci = ci)[2],
paste("upper_ci_", i+1, sep=""),bayestestR::ci(critical_mu_1*posterior_q[,i], method = 'HDI', ci = ci)[3])
list(paste("median_", i+1, sep="")=stats::median(critical_mu_1*posterior_q[,i]),
paste("median_", i+1, sep="")
list(assign(paste("median_", i+1, sep=""),stats::median(critical_mu_1*posterior_q[,i])),
assign(paste("lower_ci_", i+1, sep=""),bayestestR::ci(critical_mu_1*posterior_q[,i], method = 'HDI', ci = ci)[2]),
assign(paste("upper_ci_", i+1, sep=""),bayestestR::ci(critical_mu_1*posterior_q[,i], method = 'HDI', ci = ci)[3]))
assign(paste("out_",i+1),list(assign(paste("median_", i+1, sep=""),stats::median(critical_mu_1*posterior_q[,i])),
assign(paste("lower_ci_", i+1, sep=""),bayestestR::ci(critical_mu_1*posterior_q[,i], method = 'HDI', ci = ci)[2]),
assign(paste("upper_ci_", i+1, sep=""),bayestestR::ci(critical_mu_1*posterior_q[,i], method = 'HDI', ci = ci)[3])))
`out_ 2`
assign(paste("out",i+1,sep=""),list(assign(paste("median_", i+1, sep=""),stats::median(critical_mu_1*posterior_q[,i])),
assign(paste("lower_ci_", i+1, sep=""),bayestestR::ci(critical_mu_1*posterior_q[,i], method = 'HDI', ci = ci)[2]),
assign(paste("upper_ci_", i+1, sep=""),bayestestR::ci(critical_mu_1*posterior_q[,i], method = 'HDI', ci = ci)[3])))
out2
#create empty dataframe
out <- as.data.frame(matrix(NA,nrow=3,ncol=modelfit@par_dims$q+1))
rownames(out) <- c('median','lower_ci','upper_ci')
out
gear_names <- paste('gear_',i+1,sep='')
gear_names
colnames(out) <- c('gear_1',gear_names)
out
out[,1] <- c(stats::median(critical_mu_1),
bayestestR::ci(critical_mu_1, method = 'HDI', ci = ci)[2],
bayestestR::ci(critical_mu_1, method = 'HDI', ci = ci)[3])
stats::median(critical_mu_1)
bayestestR::ci(critical_mu_1, method = 'HDI', ci = ci)[2]
test <- bayestestR::ci(critical_mu_1, method = 'HDI', ci = ci)[2]
test[1]
test$CI_low
out[,1] <- c(stats::median(critical_mu_1),
bayestestR::ci(critical_mu_1, method = 'HDI', ci = ci)[2]$CI_low,
bayestestR::ci(critical_mu_1, method = 'HDI', ci = ci)[3]$CI_high)
out
out[,1] <- c(round(stats::median(critical_mu_1),3),
round(bayestestR::ci(critical_mu_1, method = 'HDI', ci = ci)[2]$CI_low,3),
round(bayestestR::ci(critical_mu_1, method = 'HDI', ci = ci)[3]$CI_high,3))
out
out[,1] <- c(round(stats::median(critical_mu_1),4),
round(bayestestR::ci(critical_mu_1, method = 'HDI', ci = ci)[2]$CI_low,4),
round(bayestestR::ci(critical_mu_1, method = 'HDI', ci = ci)[3]$CI_high,4))
out
out[,1] <- c(round(stats::median(critical_mu_1),6),
round(bayestestR::ci(critical_mu_1, method = 'HDI', ci = ci)[2]$CI_low,6),
round(bayestestR::ci(critical_mu_1, method = 'HDI', ci = ci)[3]$CI_high,6))
out
out[,1] <- c(stats::median(critical_mu_1),
bayestestR::ci(critical_mu_1, method = 'HDI', ci = ci)[2]$CI_low,
bayestestR::ci(critical_mu_1, method = 'HDI', ci = ci)[3]$CI_high)
out
#calculate mu_critical -- gear type 2+
for(i in 1:modelfit@par_dims$q){
out[,i+1] <- c(stats::median(stats::median(critical_mu_1*posterior_q[,i])),
bayestestR::ci(stats::median(critical_mu_1*posterior_q[,i]), method = 'HDI', ci = ci)[2]$CI_low,
bayestestR::ci(stats::median(critical_mu_1*posterior_q[,i]), method = 'HDI', ci = ci)[3]$CI_high)
}
stats::median(critical_mu_1*posterior_q[,i])
#calculate mu_critical -- gear type 2+
for(i in 1:modelfit@par_dims$q){
out[,i+1] <- c(stats::median(critical_mu_1*posterior_q[,i]),
bayestestR::ci(critical_mu_1*posterior_q[,i], method = 'HDI', ci = ci)[2]$CI_low,
bayestestR::ci(critical_mu_1*posterior_q[,i], method = 'HDI', ci = ci)[3]$CI_high)
}
out
devtools::load_all()
summarize(fit.q)
help(mu.critical)
mu.critical(fit.q,cov.val='None')
'q' %in% modelfit@model_pars
devtools::load_all()
mu.critical(fit.q)
detection.calculate(fit.q,mu=c(0.1,0.5,0.9))
detection.plot(fit.q,mu.min=0.1,mu.max=1)
summarize(fit.q,par='mu')
summarize(fit.q,par='mu').head()
mu.critical(fit.q)
devtools::load_all()
roxygen2::roxygenize()
devtools::install()
devtools::load_all()
roxygen2::roxygenize()
devtools::install()
roxygen2::roxygenize()
pkgbuild::clean_dll()
pkgbuild::compile_dll()
devtools::load_all()
data("gobyData")
help(jointModel)
fit.cov = jointModel(data=gobyData, cov=c('Filter_time','Hab_size'),family='poisson', p10priors=c(1,20), q=FALSE)
fit.cov$`log_lik[707]`
fit.cov$log_lik[707]
fit.cov
dim(gobyData$count)
gobyData$count
is.na(gobyData$count)
sum(is.na(gobyData$count))
sum(!is.na(gobyData$count))
sum(!is.na(gobyData$qPCR.K))
355+352
pkgbuild::clean_dll()
pkgbuild::compile_dll()
usethis::use_testthat(3)
usethis::use_test('jointModel')
usethis::use_test('detection.calculate')
usethis::use_test('detectioncalculate')
usethis::use_test('detectionplot')
usethis::use_test('modelselect')
usethis::use_test('mucritical')
usethis::use_test('summarize')
usethis::use_test('traditionalModel')
devtools::load_all()
data("greencrabData")
data <- greencrabData
data$count.type %% 1
data$count.type %% 1 %in% c(0,NA)
all(data$count.type %% 1 %in% c(0,NA))
test <- c(1.2,1.1,0,2)
test  %% 1
test  %% 1  %in% c(0,NA)
test <- c('1',1.1,0,2)
test
data$count.type %% 1
test %% 1
names(data)
ata=list(qPCR.N=c(1,1,1),)
ata=list(qPCR.N=c(1,1,1),qPCR.K=c(1,1,1),count=c(1,1,1))
ata
expect_equal(jointModel(data=list(qPCR.n=c(1,1,1),qPCR.k=c(1,1,1),count=c(1,1,1))),
"Data should include 'qPCR.N', 'qPCR.K', and 'count'.")
jointModel(data=list(qPCR.n=c(1,1,1),qPCR.k=c(1,1,1),count=c(1,1,1)))
expect_error(jointModel(data=list(qPCR.n=c(1,1,1),qPCR.k=c(1,1,1),count=c(1,1,1))),
"Data should include 'qPCR.N', 'qPCR.K', and 'count'.")
expect_error(jointModel(data=list(qPCR.N=c(1,1,1),qPCR.K=c(1,1,1),count=c(1,1,1))),
"Data should include 'qPCR.N', 'qPCR.K', and 'count'.")
rbind(c(1,1,1),c(1,1,1))
expect_error(jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA)))),
"Data should include 'qPCR.N', 'qPCR.K', and 'count'.")
expect_error(jointModel(data=list(qPCR.n=rbind(c(1,1,1),c(1,1,NA)),
qPCR.k=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA)))),
"Data should include 'qPCR.N', 'qPCR.K', and 'count'.")
#2. input tags are valid, q = TRUE, site.cov = FALSE
expect_error(jointModel(data=list(qPCR.n=rbind(c(1,1,1),c(1,1,NA)),
qPCR.k=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c(1,2,1),c(1,2,NA))),
q=TRUE),
"Data should include 'qPCR.N', 'qPCR.K', 'count', and 'count.type'.")
site.cov=rbind(c(1,0),c(0.4,-0.4))
site.cov
site.cov=rbind(c(1,0),c(0.4,-0.4))
colnames(site.cov)=c('var_a','var_b')
expect_error(jointModel(data=list(qPCR.n=rbind(c(1,1,1),c(1,1,NA)),
qPCR.k=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA)),
site.cov=site.cov)),
"Data should include 'qPCR.N', 'qPCR.K', 'count', and 'site.cov'.")
expect_error(jointModel(data=list(qPCR.n=rbind(c(1,1,1),c(1,1,NA)),
qPCR.k=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA)),
site.cov=site.cov),
cov=c('var_a','var_b')),
"Data should include 'qPCR.N', 'qPCR.K', 'count', and 'site.cov'.")
expect_error(jointModel(data=list(qPCR.n=rbind(c(1,1,1),c(1,1,NA)),
qPCR.k=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c(1,2,1),c(1,2,NA)),
site.cov=site.cov),
cov=c('var_a','var_b')),
"Data should include 'qPCR.N', 'qPCR.K', 'count', 'count.type', and 'site.cov'.")
expect_error(jointModel(data=list(qPCR.n=rbind(c(1,1,1),c(1,1,NA)),
qPCR.k=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c(1,2,1),c(1,2,NA)),
site.cov=site.cov),
cov=c('var_a','var_b'),q=TRUE),
"Data should include 'qPCR.N', 'qPCR.K', 'count', 'count.type', and 'site.cov'.")
#5. make sure dimensions of qPCR.N and qPCR.K are equal
expect_error(jointModel(data=list(qPCR.N=rbind(c(1,1,1,1),c(1,1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA)))),
"Dimensions of qPCR.N and qPCR.K do not match.")
devtools::load_all()
#5. make sure dimensions of qPCR.N and qPCR.K are equal
expect_error(jointModel(data=list(qPCR.N=rbind(c(1,1,1,1),c(1,1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA)))),
"Dimensions of qPCR.N and qPCR.K do not match.")
#6. make sure dimensions of count and count.type are equal, if count.type is present
expect_error(jointModel(data=list(qPCR.n=rbind(c(1,1,1),c(1,1,NA)),
qPCR.k=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c(1,2),c(1,2))),
q=TRUE),
"Dimensions of count and count.type do not match.")
#6. make sure dimensions of count and count.type are equal, if count.type is present
expect_error(jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c(1,2),c(1,2))),
q=TRUE),
"Dimensions of count and count.type do not match.")
#7. make sure number of rows in count = number of rows in qPCR.N and qPCR.K
expect_error(jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA),c(4,2,1)))),
"Number of sites (rows) in qPCR data and traditional survey count data do not match.")
#7. make sure number of rows in count = number of rows in qPCR.N and qPCR.K
expect_error(jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA),c(4,2,1)))),
"Number of sites (rows) in qPCR data and traditional survey count data do not match.")
jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA),c(4,2,1))))
jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA),c(4,2,1))))
expect_error(jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA),c(4,2,1)))),
"Number of sites (rows) in qPCR data and traditional survey count data do not match.")
#6. make sure dimensions of count and count.type are equal, if count.type is present
expect_error(jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c(1,2),c(1,2))),
q=TRUE),
"Dimensions of count and count.type do not match.")
#7. make sure number of rows in count = number of rows in qPCR.N and qPCR.K
expect_error(jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA),c(4,2,1)))),
"Number of sites (rows) in qPCR data and traditional survey count data do not match.")
#7. make sure number of rows in count = number of rows in qPCR.N and qPCR.K
expect_error(jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA),c(4,2,1)))),
"Number of sites (rows) in qPCR data and traditional survey count data do not match.")
rbind(c(1,1,1),c(1,1,NA))
rbind(c(3,3,3),c(3,3,NA))
rbind(c(4,1,1),c(1,1,NA),c(4,2,1))
#7. make sure number of rows in count = number of rows in qPCR.N and qPCR.K
expect_error(jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA),c(4,2,1)))),
"Number of sites (rows) in qPCR data and traditional survey count data do not match.")
jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c(1,2),c(1,2))),
q=TRUE)
jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA),c(4,2,1))))
#7. make sure number of rows in count = number of rows in qPCR.N and qPCR.K
expect_error(jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA),c(4,2,1)))),
"Number of sites (rows) in qPCR data and traditional survey count data do not match.")
#6. make sure dimensions of count and count.type are equal, if count.type is present
expect_error(jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c(1,2),c(1,2))),
q=TRUE),
"Dimensions of count and count.type do not match.")
#7. make sure number of rows in count = number of rows in qPCR.N and qPCR.K
expect_error(jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA),c(4,2,1)))),
"Number of sites (rows) in qPCR data and traditional survey count data do not match.")
library(testthat)
#7. make sure number of rows in count = number of rows in qPCR.N and qPCR.K
expect_error(jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA),c(4,2,1)))),
"Number of sites (rows) in qPCR data and traditional survey count data do not match.")
#6. make sure dimensions of count and count.type are equal, if count.type is present
expect_error(jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c(1,2),c(1,2))),
q=TRUE),
"Dimensions of count and count.type do not match.")
qPCR.N=rbind(c(1,1,1),c(1,1,NA))
qPCR.K=rbind(c(3,3,3),c(3,3,NA))
count=rbind(c(4,1,1),c(1,1,NA),c(4,2,1))
dim(data$qPCR.N)[1]!=dim(data$count)[1]
dim(data$qPCR.N)[1]
dim(data$count)[1]
dim(data$count)[1]
data
rm(data)
#7. make sure number of rows in count = number of rows in qPCR.N and qPCR.K
expect_error(jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA),c(4,2,1))
)),
"Number of sites (rows) in qPCR data and traditional survey count data do not match.")
#6. make sure dimensions of count and count.type are equal, if count.type is present
expect_error(jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c(1,2),c(1,2))),
q=TRUE),
"Dimensions of count and count.type do not match.")
jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA),c(4,2,1))
))
dim(qPCR.N)
dim(count)
#8. make sure all data is numeric -- if q == TRUE
expect_error(jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c('NA',2),c(1,2))),
q=TRUE),
"Data should be numeric (i.e. contain integers or NA).")
#8. make sure all data is numeric -- if q == TRUE
expect_error(jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c('NA',2,2),c(1,2,2))),
q=TRUE),
"Data should be numeric (i.e. contain integers or NA).")
#6. make sure dimensions of count and count.type are equal, if count.type is present
expect_error(jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c(1,2),c(1,2))),
q=TRUE),
"Dimensions of count and count.type do not match.")
#1. input tags are valid, q = FALSE, cov = FALSE
expect_error(jointModel(data=list(qPCR.n=rbind(c(1,1,1),c(1,1,NA)),
qPCR.k=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA)))),
"Data should include 'qPCR.N', 'qPCR.K', and 'count'.")
#2. input tags are valid, q = FALSE, cov = TRUE
site.cov=rbind(c(1,0),c(0.4,-0.4))
colnames(site.cov)=c('var_a','var_b')
expect_error(jointModel(data=list(qPCR.n=rbind(c(1,1,1),c(1,1,NA)),
qPCR.k=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA)),
site.cov=site.cov),
cov=c('var_a','var_b')),
"Data should include 'qPCR.N', 'qPCR.K', 'count', and 'site.cov'.")
#3. input tags are valid, q = TRUE, cov = FALSE
expect_error(jointModel(data=list(qPCR.n=rbind(c(1,1,1),c(1,1,NA)),
qPCR.k=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c(1,2,1),c(1,2,NA))),
q=TRUE),
"Data should include 'qPCR.N', 'qPCR.K', 'count', and 'count.type'.")
#4. input tags are valid, q = TRUE, cov = TRUE
site.cov=rbind(c(1,0),c(0.4,-0.4))
colnames(site.cov)=c('var_a','var_b')
expect_error(jointModel(data=list(qPCR.n=rbind(c(1,1,1),c(1,1,NA)),
qPCR.k=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c(1,2,1),c(1,2,NA)),
site.cov=site.cov),
cov=c('var_a','var_b'),q=TRUE),
"Data should include 'qPCR.N', 'qPCR.K', 'count', 'count.type', and 'site.cov'.")
#5. make sure dimensions of qPCR.N and qPCR.K are equal
expect_error(jointModel(data=list(qPCR.N=rbind(c(1,1,1,1),c(1,1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA)))),
"Dimensions of qPCR.N and qPCR.K do not match.")
#6. make sure dimensions of count and count.type are equal, if count.type is present
expect_error(jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c(1,2),c(1,2))),
q=TRUE),
"Dimensions of count and count.type do not match.")
#7. make sure number of rows in count = number of rows in qPCR.N and qPCR.K
expect_error(jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA),c(4,2,1))
)),
"Number of sites (rows) in qPCR data and traditional survey count data do not match.")
#8. make sure all data is numeric -- if q == TRUE
expect_error(jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c('NA',2,2),c(1,2,2))),
q=TRUE),
"Data should be numeric (i.e. contain integers or NA).")
#6. make sure dimensions of count and count.type are equal, if count.type is present
expect_error(jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c(1,2),c(1,2))),
q=TRUE),
"Dimensions of count and count.type do not match.")
#6. make sure dimensions of count and count.type are equal, if count.type is present
expect_error(jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c(1,2),c(1,2))),
q=TRUE),
"Dimensions of count and count.type do not match.")
#7. make sure number of rows in count = number of rows in qPCR.N and qPCR.K
expect_error(jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA),c(4,2,1))
)),
"Number of sites (rows) in qPCR data and traditional survey count data do not match.")
jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA),c(4,2,1))
))
jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c(1,2),c(1,2))),
q=TRUE)
#6. make sure dimensions of count and count.type are equal, if count.type is present
expect_error(jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c(1,2),c(1,2))),
q=TRUE),
"Dimensions of count and count.type do not match.")
#8. make sure all data is numeric -- if q == TRUE
expect_error(jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c('NA',2,2),c(1,2,2))),
q=TRUE),
"Data should be numeric (i.e. contain integers or NA).")
