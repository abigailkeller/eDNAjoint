"The number of rows in site.cov matrix should match the number of rows in all other matrices.")
#25. make sure count.type is not zero-length
expect_error(jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA)),
count.type=matrix(NA,ncol=3,nrow=0)),
q=TRUE),
"count.type contains zero-length data.")
#26. make sure no column is entirely NA in count.type
expect_error(jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c(4,1,NA),c(1,1,NA))),
q=TRUE),
"count.type contains a column with all NA.")
#27. make sure no column is entirely NA in qPCR.N
expect_error(jointModel(data=list(qPCR.N=rbind(c(1,1,NA),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA)))),
"qPCR.N contains a column with all NA.")
#28. make sure no column is entirely NA in qPCR.K
expect_error(jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,NA),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA)))),
"qPCR.K contains a column with all NA.")
#29. make sure no column is entirely NA in count
expect_error(jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,NA),c(1,1,NA)))),
"count contains a column with all NA.")
#30. make sure no data are undefined
expect_error(jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,Inf),c(1,1,NA)))),
"count contains undefined values \\(i.e., Inf or -Inf\\)")
#31. make sure no data are undefined
expect_error(jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,Inf),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA)))),
"qPCR.K contains undefined values \\(i.e., Inf or -Inf\\)")
#32. make sure no data are undefined
expect_error(jointModel(data=list(qPCR.N=rbind(c(1,1,Inf),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA)))),
"qPCR.N contains undefined values \\(i.e., Inf or -Inf\\)")
#33. make sure site.cov is not zero-length
site.cov=matrix(NA,ncol=2,nrow=0)
colnames(site.cov)=c('var_a','var_b')
expect_error(jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA)),
site.cov=site.cov),
cov=c('var_a','var_b')),
"site.cov contains zero-length data.")
#34. make sure no column is entirely NA in site.cov
site.cov=rbind(c(4,1,NA),c(1,1,NA))
colnames(site.cov)=c('var_a','var_b','var_c')
expect_error(jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA)),
site.cov=site.cov),
cov=c('var_a','var_b')),
"site.cov contains a column with all NA.")
#35. make sure no data are undefined
site.cov=rbind(c(4,1,Inf),c(1,1,NA))
colnames(site.cov)=c('var_a','var_b','var_c')
expect_error(jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA)),
site.cov=site.cov),
cov=c('var_a','var_b')),
"site.cov contains undefined values \\(i.e., Inf or -Inf\\)")
#36. length of initial values is equal to the number of chains
n.chain <- 4
inits <- list()
for(i in 1:n.chain){
inits[[i]] <- list(
mu = stats::runif(3, 0.01, 5),
p10 = stats::runif(1,log(0.0001),log(0.08)),
alpha = rep(0.1,3)
)
}
site.cov=rbind(c(4,1),c(1,1))
colnames(site.cov)=c('var_a','var_b')
expect_error(jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA)),
site.cov=site.cov),
cov=c('var_a','var_b'), initial_values=inits,
n.chain=5),
"The length of the list of initial values should equal the number of chains \\(n.chain, default is 4\\).")
#37. initial values check: if mu is numeric
n.chain <- 4
inits <- list()
for(i in 1:n.chain){
inits[[i]] <- list(
mu = stats::runif(3, -1, 0),
p10 = stats::runif(1,log(0.0001),log(0.08)),
alpha = rep(0.1,3)
)
}
site.cov=rbind(c(4,1),c(1,1))
colnames(site.cov)=c('var_a','var_b')
expect_error(jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA)),
site.cov=site.cov),
cov=c('var_a','var_b'), initial_values=inits),
"Initial values for 'mu' should be numeric values > 0.")
#38. initial values check: mu length
n.chain <- 4
inits <- list()
for(i in 1:n.chain){
inits[[i]] <- list(
mu = stats::runif(4, 0.1, 1),
p10 = stats::runif(1,log(0.0001),log(0.08)),
alpha = rep(0.1,3)
)
}
site.cov=rbind(c(4,1),c(1,1))
colnames(site.cov)=c('var_a','var_b')
expect_error(jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA)),
site.cov=site.cov),
cov=c('var_a','var_b'), initial_values=inits),
"The length of initial values for 'mu' should equal the number of sites.")
#39. initial values check: p10 length
n.chain <- 4
inits <- list()
for(i in 1:n.chain){
inits[[i]] <- list(
mu = stats::runif(2,0,1),
p10 = stats::runif(2,log(0.0001),log(0.08)),
alpha = rep(0.1,3)
)
}
site.cov=rbind(c(4,1),c(1,1))
colnames(site.cov)=c('var_a','var_b')
expect_error(jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA)),
site.cov=site.cov),
cov=c('var_a','var_b'), initial_values=inits),
"The length of initial values for 'p10' should equal 1.")
#40. initial values check: beta length
n.chain <- 4
inits <- list()
for(i in 1:n.chain){
inits[[i]] <- list(
mu = stats::runif(2,0,1),
p10 = stats::runif(1,log(0.0001),log(0.08)),
beta = c(1,0)
)
}
expect_error(jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA))),
initial_values=inits),
"The length of initial values for 'beta' should equal 1.")
#41. initial values check: alpha length
n.chain <- 4
inits <- list()
for(i in 1:n.chain){
inits[[i]] <- list(
mu = stats::runif(2,0,1),
p10 = stats::runif(1,log(0.0001),log(0.08)),
alpha = rep(0.1,2)
)
}
site.cov=rbind(c(4,1),c(1,1))
colnames(site.cov)=c('var_a','var_b')
expect_error(jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA)),
site.cov=site.cov),
cov=c('var_a','var_b'), initial_values=inits),
"The length of initial values for 'alpha' should equal\\: \\# covariates \\+ 1 \\(i.e., including intercept\\).")
#42. initial values check: beta length
n.chain <- 4
inits <- list()
for(i in 1:n.chain){
inits[[i]] <- list(
q = c(0.1,0.1)
)
}
expect_error(jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c(1,2,1),c(1,1,NA))),
initial_values=inits),
"The length of initial values for 'q' should equal: \\# unique gear types \\- 1 \\(i.e., q for reference type = 1\\).")
#12. make sure no column is entirely NA in count
expect_error(traditionalModel(data=list(count=rbind(c(4,1,NA),c(1,1,NA)))),
"count contains a column with all NA.")
#13. make sure no data are undefined
expect_error(traditionalModel(data=list(count=rbind(c(4,1,Inf),c(1,1,NA)))),
"count contains undefined values (i.e., Inf or -Inf)")
#13. make sure no data are undefined
expect_error(traditionalModel(data=list(count=rbind(c(4,1,Inf),c(1,1,NA)))),
"count contains undefined values \\(i.e., Inf or -Inf\\)")
#13. make sure no data are undefined
expect_error(traditionalModel(data=list(count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c(1,0,1),c(Inf,1,1)))),
"count.type contains undefined values \\(i.e., Inf or -Inf\\)")
count.type=rbind(c(1,0,1),c(Inf,1,1))
count.type
#14 make sure no data are undefined
n.chain <- 4
inits <- list()
for(i in 1:n.chain){
inits[[i]] <- list(
mu = stats::runif(2,0,1)
)
}
expect_error(traditionalModel(data=list(count=rbind(c(4,1,1),c(1,1,NA))),
n.chain=5, initial_values=inits),
"The length of the list of initial values should equal the number of chains \\(n.chain, default is 4\\).")
#15. initial values check mu length
n.chain <- 4
inits <- list()
for(i in 1:n.chain){
inits[[i]] <- list(
mu = stats::runif(3,0,1)
)
}
expect_error(traditionalModel(data=list(count=rbind(c(4,1,1),c(1,1,NA))),
initial_values=inits),
"The length of initial values for 'mu' should equal the number of sites.")
#16. initial values check mu is positive numeric
n.chain <- 4
inits <- list()
for(i in 1:n.chain){
inits[[i]] <- list(
mu = stats::runif(3,-1,0)
)
}
expect_error(traditionalModel(data=list(count=rbind(c(4,1,1),c(1,1,NA))),
initial_values=inits),
"Initial values for 'mu' should be numeric values > 0.")
#17. initial values check q
n.chain <- 4
inits <- list()
for(i in 1:n.chain){
inits[[i]] <- list(
q = c(0.1,0.1)
)
}
expect_error(traditionalModel(data=list(count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c(1,1,2),c(1,2,NA))),
initial_values=inits),
"The length of initial values for 'q' should equal: \\# unique gear types \\- 1 \\(i.e., q for reference type = 1\\).")
#1. input tags are valid, q = TRUE
expect_error(traditionalModel(data=list(Count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c(1,2,1),c(1,2,NA))),q=TRUE),
"Data should include 'count' and 'count.type'.")
#2. input tags are valid, q = FALSE
expect_error(traditionalModel(data=list(Count=rbind(c(4,1,1),c(1,1,NA)))),
"Data should include 'count'.")
#3. make sure dimensions of count and count.type are equal, if count.type is present
#' @srrstats {BS2.1a} Test to ensure pre-processing routines to ensure all input data is dimensionally commensurate
expect_error(traditionalModel(data=list(count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c(1,2),c(1,2))),
q=TRUE),
"Dimensions of count and count.type do not match.")
#4. make sure all data is numeric -- if q == TRUE
expect_error(traditionalModel(data=list(count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c('NA',2,2),c(1,2,2))),
q=TRUE),
"Data should be numeric.")
#5. make sure all data is numeric -- if q == FALSE
expect_error(traditionalModel(data=list(count=rbind(c(4,1,1),c(1,1,'NA')))),
"Data should be numeric.")
#6. make sure locations of NAs in count data match locations of NAs in count.type data
expect_error(traditionalModel(data=list(count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c(NA,2,2),c(1,2,2))),
q=TRUE),
"Empty data cells \\(NA\\) in count data should match empty data cells \\(NA\\) in count.type data.")
#7. make sure family is either 'poisson', 'negbin', or 'gamma'
expect_error(traditionalModel(data=list(count=rbind(c(4,1,1),c(1,1,NA))),
family='normal'),
"Invalid family. Options include 'poisson', 'negbin', or 'gamma'.")
#8. the smallest count.type is 1
expect_error(traditionalModel(data=list(count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c(0,1,2),c(1,2,NA))),
q=TRUE),
"The first gear type should be referenced as 1 in count.type. Subsequent gear types should be referenced 2, 3, 4, etc.")
#9. count are integers
expect_error(traditionalModel(data=list(count=rbind(c(4.1,1,1),c(1,1,NA)),
count.type=rbind(c(1,1,2),c(1,2,NA))),
q=TRUE, family = 'negbin'),
"All values in count should be non-negative integers. Use family = 'gamma' if count is continuous.")
#10. count.type are integers
expect_error(traditionalModel(data=list(count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c(1.1,1,2),c(1,2,NA))),
q=TRUE),
"All values in count.type should be integers.")
#11. phi priors is a vector of two numeric values
expect_error(traditionalModel(data=list(count=rbind(c(4,1,1),c(1,1,NA))),
phipriors=c(0,1)),
"phipriors should be a vector of two positive numeric values. ex. c\\(0.25,0.25\\)")
#12. make sure no column is entirely NA in count
expect_error(traditionalModel(data=list(count=rbind(c(4,1,NA),c(1,1,NA)))),
"count contains a column with all NA.")
#13. make sure no data are undefined
expect_error(traditionalModel(data=list(count=rbind(c(4,1,Inf),c(1,1,NA)))),
"count contains undefined values \\(i.e., Inf or -Inf\\)")
#14. length of initial values is equal to the number of chains
n.chain <- 4
inits <- list()
for(i in 1:n.chain){
inits[[i]] <- list(
mu = stats::runif(2,0,1)
)
}
expect_error(traditionalModel(data=list(count=rbind(c(4,1,1),c(1,1,NA))),
n.chain=5, initial_values=inits),
"The length of the list of initial values should equal the number of chains \\(n.chain, default is 4\\).")
#15. initial values check mu length
n.chain <- 4
inits <- list()
for(i in 1:n.chain){
inits[[i]] <- list(
mu = stats::runif(3,0,1)
)
}
expect_error(traditionalModel(data=list(count=rbind(c(4,1,1),c(1,1,NA))),
initial_values=inits),
"The length of initial values for 'mu' should equal the number of sites.")
#16. initial values check mu is positive numeric
n.chain <- 4
inits <- list()
for(i in 1:n.chain){
inits[[i]] <- list(
mu = stats::runif(3,-1,0)
)
}
expect_error(traditionalModel(data=list(count=rbind(c(4,1,1),c(1,1,NA))),
initial_values=inits),
"Initial values for 'mu' should be numeric values > 0.")
#17. initial values check q
n.chain <- 4
inits <- list()
for(i in 1:n.chain){
inits[[i]] <- list(
q = c(0.1,0.1)
)
}
expect_error(traditionalModel(data=list(count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c(1,1,2),c(1,2,NA))),
initial_values=inits),
"The length of initial values for 'q' should equal: \\# unique gear types \\- 1 \\(i.e., q for reference type = 1\\).")
# run joint model to do tests with
model1 <- jointModel(data=gobyData, cov=c('Filter_time','Salinity'),multicore=FALSE,
n.chain=2,n.iter.burn=50,n.iter.sample=200)
model2 <- jointModel(data=greencrabData,family='negbin',multicore=FALSE,
n.chain=2,n.iter.burn=50,n.iter.sample=200)
#1. make sure model fit is of class stanfit
expect_error(detectionCalculate(as.matrix(model1$model), mu = c(0.1, 0.5), cov.val = c(0,0)),
"modelfit must be of class 'stanfit'.")
#2. make sure ci is valid
expect_error(detectionCalculate(model1$model, mu = c('0', 0.5), cov.val = c(0,0)),
"mu must be a numeric vector of positive values")
#3. make sure mu is a numeric vector of positive values
expect_error(detectionCalculate(model1$model, mu = c(0, 0.5), cov.val = c(0,0)),
"mu must be a numeric vector of positive values")
#4. make sure probability is a numeric value between 0 and 1
expect_error(detectionCalculate(model1$model, mu = c(0.1, 0.5), cov.val = c(0,0), probability = 1.05),
"probability must be a numeric value between 0 and 1")
#5. cov.val is numeric, if provided
expect_error(detectionCalculate(model1$model, mu = c(0.1, 0.5), cov.val = c('0',0)),
"cov.val must be a numeric vector")
#6. Only include input cov.val if covariates are included in model
expect_error(detectionCalculate(model2$model, mu = c(0.1, 0.5), cov.val = c(0,0)),
"cov.val must be 'None' if the model does not contain site-level covariates.")
#7. Input cov.val is the same length as the number of estimated covariates.
expect_error(detectionCalculate(model1$model, mu = c(0.1, 0.5), cov.val = c(0,0,0)),
"cov.val must be of the same length as the number of non-intercept site-level coefficients in the model.")
#8. If covariates are in model, cov.val must be provided
expect_error(detectionCalculate(model1$model, mu = c(0.1, 0.5)),
"cov.val must be provided if the model contains site-level covariates.")
#9. qPCR.N must be an integer
expect_error(detectionCalculate(model1$model, mu = c(0.1, 0.5), cov.val = c(0,0,0), qPCR.N = 6.8),
"qPCR.N should be an integer.")
#1. make sure model fit is of class stanfit
expect_error(detectionCalculate(as.matrix(model1$model), mu = c(0.1, 0.5), cov.val = c(0,0)),
"modelfit must be of class 'stanfit'.")
#2. make sure ci is valid
expect_error(detectionCalculate(model1$model, mu = c('0', 0.5), cov.val = c(0,0)),
"mu must be a numeric vector of positive values")
#3. make sure mu is a numeric vector of positive values
expect_error(detectionCalculate(model1$model, mu = c(0, 0.5), cov.val = c(0,0)),
"mu must be a numeric vector of positive values")
#4. make sure probability is a numeric value between 0 and 1
expect_error(detectionCalculate(model1$model, mu = c(0.1, 0.5), cov.val = c(0,0), probability = 1.05),
"probability must be a numeric value between 0 and 1")
#5. cov.val is numeric, if provided
expect_error(detectionCalculate(model1$model, mu = c(0.1, 0.5), cov.val = c('0',0)),
"cov.val must be a numeric vector")
#6. Only include input cov.val if covariates are included in model
expect_error(detectionCalculate(model2$model, mu = c(0.1, 0.5), cov.val = c(0,0)),
"cov.val must be 'None' if the model does not contain site-level covariates.")
#7. Input cov.val is the same length as the number of estimated covariates.
expect_error(detectionCalculate(model1$model, mu = c(0.1, 0.5), cov.val = c(0,0,0)),
"cov.val must be of the same length as the number of non-intercept site-level coefficients in the model.")
#8. If covariates are in model, cov.val must be provided
expect_error(detectionCalculate(model1$model, mu = c(0.1, 0.5)),
"cov.val must be provided if the model contains site-level covariates.")
#9. qPCR.N must be an integer
expect_error(detectionCalculate(model1$model, mu = c(0.1, 0.5), cov.val = c(0,0,0), qPCR.N = 6.8),
"qPCR.N should be an integer.")
#9. qPCR.N must be an integer
expect_error(detectionCalculate(model1$model, mu = c(0.1, 0.5), cov.val = c(0,0), qPCR.N = 6.8),
"qPCR.N should be an integer.")
#1. make sure model fit is of class stanfit
expect_error(detectionPlot(as.matrix(model1$model), mu.min = 0.1, mu.max = 1, cov.val = c(0,0)),
"modelfit must be of class 'stanfit'.")
#2. make sure mu.min is a numeric value
expect_error(detectionPlot(model1$model, mu.min = '0.1', mu.max = 1, cov.val = c(0,0)),
"mu.min must be a numeric value greater than 0")
#3. make sure mu.min is a numeric value
expect_error(detectionPlot(model1$model, mu.min = 0, mu.max = 1, cov.val = c(0,0)),
"mu.min must be a numeric value greater than 0")
#4. make sure mu.max is a numeric value
expect_error(detectionPlot(model1$model, mu.min = 0.1, mu.max = '1', cov.val = c(0,0)),
"mu.max must be a numeric value greater than mu.min")
#5. make sure mu.max is a numeric value
expect_error(detectionPlot(model1$model, mu.min = 0.1, mu.max = 0.1, cov.val = c(0,0)),
"mu.max must be a numeric value greater than mu.min")
#6. make sure mu.max is a numeric value
expect_error(detectionPlot(model1$model, mu.min = 0.1, mu.max = 1, cov.val = c(0,0), probability = 1.1),
"probability must be a numeric value between 0 and 1")
#7. cov.val is numeric, if provided
expect_error(detectionPlot(model1$model, mu.min = 0.1, mu.max = 1, cov.val = c(0,'0')),
"cov.val must be a numeric vector")
#8. Only include input cov.val if covariates are included in model
expect_error(detectionPlot(model2$model, mu.min = 0.1, mu.max = 1, cov.val = c(0,0)),
"cov.val must be 'None' if the model does not contain site-level covariates.")
#9. Input cov.val is the same length as the number of estimated covariates.
expect_error(detectionPlot(model1$model, mu.min = 0.1, mu.max = 1, cov.val = c(0,0,0)),
"cov.val must be of the same length as the number of non-intercept site-level coefficients in the model.")
#10. If covariates are in model, cov.val must be provided
expect_error(detectionPlot(model1$model, mu.min = 0.1, mu.max = 1),
"cov.val must be provided if the model contains site-level covariates.")
#11. qPCR.N must be an integer
expect_error(detectionPlot(model1$model, mu.min = 0.1, mu.max = 1, qPCR.N = 6.8),
"qPCR.N should be an integer.")
#11. qPCR.N must be an integer
expect_error(detectionPlot(model1$model, mu.min = 0.1, mu.max = 1, cov.val = c(0,0), qPCR.N = 6.8),
"qPCR.N should be an integer.")
#1. make sure model fit is of class stanfit
data <- data.frame(y=c(1,2,3),x=c(1,2,3))
lm_out <- lm(y ~ x, data=data)
expect_error(jointSummarize(lm_out$model),
"modelfit must be of class 'stanfit'.")
out <- model2
#2. make sure probs is a numeric vector
expect_error(jointSummarize(out$model,probs=c('95%')),
"probs must be a numeric vector.")
#3. make sure all values of probs are between 0 and 1
expect_error(jointSummarize(out$model,probs=c(5,95)),
"probs must be between 0 and 1.")
#4. make sure par is a character vector
expect_error(jointSummarize(out$model,par=c(1,2,3)),
"par must be a character vector.")
#5. make sure model fit contains all par input
expect_error(jointSummarize(out$model,par='alpha'),
"modelfit must contain all selected parameters: alpha")
#1. make sure model fit is of class stanfit
expect_error(muCritical(as.matrix(model1$model), cov.val = c(0,0)),
"modelfit must be of class 'stanfit'.")
#2. make sure ci is valid
expect_error(muCritical(model1$model, ci = 1, cov.val = c(0,0)),
"ci must be a numeric value >0 and <1.")
#3. make sure model fit contains p10 parameter
expect_error(muCritical(model2$model),
"modelfit must contain 'p10' parameter.")
#4. if modelfit contains alpha, cov.val must be provided
expect_error(muCritical(model1$model),
"If modelfit contains site-level covariates, values must be provided for cov.val")
#5. cov.val is numeric, if provided
expect_error(muCritical(model1$model, cov.val=c(TRUE,TRUE)),
"cov.val must be a numeric vector")
#6. Only include input cov.val if covariates are included in model
expect_error(muCritical(model3$model, cov.val=c(0,0)),
"cov.val must be 'None' if the model does not contain site-level covariates.")
#6. Only include input cov.val if covariates are included in model
expect_error(muCritical(model2$model, cov.val=c(0,0)),
"cov.val must be 'None' if the model does not contain site-level covariates.")
#7. Only include input cov.val if covariates are included in model
expect_error(muCritical(model1$model, cov.val=c(0,0,0)),
"cov.val must be of the same length as the number of non-intercept site-level coefficients in the model.")
#1. make sure model fit is of class stanfit
expect_error(muCritical(as.matrix(model1$model), cov.val = c(0,0)),
"modelfit must be of class 'stanfit'.")
#2. make sure ci is valid
expect_error(muCritical(model1$model, ci = 1, cov.val = c(0,0)),
"ci must be a numeric value >0 and <1.")
#3. make sure model fit contains p10 parameter
expect_error(muCritical(model2$model),
"modelfit must contain 'p10' parameter.")
#4. if modelfit contains alpha, cov.val must be provided
expect_error(muCritical(model1$model),
"If modelfit contains site-level covariates, values must be provided for cov.val")
#5. cov.val is numeric, if provided
expect_error(muCritical(model1$model, cov.val=c(TRUE,TRUE)),
"cov.val must be a numeric vector")
#6. Only include input cov.val if covariates are included in model
expect_error(muCritical(model2$model, cov.val=c(0,0)),
"cov.val must be 'None' if the model does not contain site-level covariates.")
roxygen2::roxygenise()
roxygen2::roxygenise()
