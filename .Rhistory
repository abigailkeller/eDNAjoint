count=count,
count.type=count.type,
site.cov=gobyData$site.cov[1:10,])
out <- jointModel(data=test,q=TRUE,family='gamma',
cov=c('Filter_time','Salinity'),
n.chain=1,n.iter.burn=500,
n.iter.sample=500)
expect_type(sum(colMeans(rstan::extract(out,par='log_lik')$log_lik)), 'double')
#1. input tags are valid, q = TRUE
expect_error(traditionalModel(data=list(Count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c(1,2,1),c(1,2,NA))),q=TRUE),
"Data should include 'count' and 'count.type'.")
#2. input tags are valid, q = FALSE
expect_error(traditionalModel(data=list(Count=rbind(c(4,1,1),c(1,1,NA)))),
"Data should include 'count'.")
#3. make sure dimensions of count and count.type are equal, if count.type is present
expect_error(traditionalModel(data=list(count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c(1,2),c(1,2))),
q=TRUE),
"Dimensions of count and count.type do not match.")
#4. make sure all data is numeric -- if q == TRUE
expect_error(traditionalModel(data=list(count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c('NA',2,2),c(1,2,2))),
q=TRUE),
"Data should be numeric \\(i.e. contain integers or NA\\).")
#5. make sure all data is numeric -- if q == FALSE
expect_error(traditionalModel(data=list(count=rbind(c(4,1,1),c(1,1,'NA')))),
"Data should be numeric \\(i.e. contain integers or NA\\).")
#6. make sure locations of NAs in count data match locations of NAs in count.type data
expect_error(traditionalModel(data=list(count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c(NA,2,2),c(1,2,2))),
q=TRUE),
"Empty data cells \\(NA\\) in count data should match empty data cells \\(NA\\) in count.type data.")
#7. make sure family is either 'poisson' or 'negbin'
expect_error(traditionalModel(data=list(count=rbind(c(4,1,1),c(1,1,NA))),
family='normal'),
"Invalid family. Options include 'poisson' and 'negbin'.")
traditionalModel(data=list(count=rbind(c(4,1,1),c(1,1,NA))),
family='normal')
traditionalModel(data=list(count=rbind(c(4,1,1),c(1,1,'NA'))))
devtools::load_all()
#1. input tags are valid, q = TRUE
expect_error(traditionalModel(data=list(Count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c(1,2,1),c(1,2,NA))),q=TRUE),
"Data should include 'count' and 'count.type'.")
#2. input tags are valid, q = FALSE
expect_error(traditionalModel(data=list(Count=rbind(c(4,1,1),c(1,1,NA)))),
"Data should include 'count'.")
#3. make sure dimensions of count and count.type are equal, if count.type is present
expect_error(traditionalModel(data=list(count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c(1,2),c(1,2))),
q=TRUE),
"Dimensions of count and count.type do not match.")
#4. make sure all data is numeric -- if q == TRUE
expect_error(traditionalModel(data=list(count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c('NA',2,2),c(1,2,2))),
q=TRUE),
"Data should be numeric \\(i.e. contain integers or NA\\).")
#4. make sure all data is numeric -- if q == TRUE
expect_error(traditionalModel(data=list(count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c('NA',2,2),c(1,2,2))),
q=TRUE),
"Data should be numeric.")
#5. make sure all data is numeric -- if q == FALSE
expect_error(traditionalModel(data=list(count=rbind(c(4,1,1),c(1,1,'NA')))),
"Data should be numeric \\(i.e. contain integers or NA\\).")
#5. make sure all data is numeric -- if q == FALSE
expect_error(traditionalModel(data=list(count=rbind(c(4,1,1),c(1,1,'NA')))),
"Data should be numeric.")
#6. make sure locations of NAs in count data match locations of NAs in count.type data
expect_error(traditionalModel(data=list(count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c(NA,2,2),c(1,2,2))),
q=TRUE),
"Empty data cells \\(NA\\) in count data should match empty data cells \\(NA\\) in count.type data.")
#7. make sure family is either 'poisson' or 'negbin'
expect_error(traditionalModel(data=list(count=rbind(c(4,1,1),c(1,1,NA))),
family='normal'),
"Invalid family. Options include 'poisson', 'negbin', and 'gamma'.")
#7. make sure family is either 'poisson' or 'negbin'
expect_error(traditionalModel(data=list(count=rbind(c(4,1,1),c(1,1,NA))),
family='normal'),
"Invalid family. Options include 'poisson', 'negbin', or 'gamma'.")
#8. the smallest count.type is 1
expect_error(traditionalModel(data=list(count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c(0,1,2),c(1,2,NA))),
q=TRUE),
"The first gear type should be referenced as 1 in count.type. Subsequent gear types should be referenced 2, 3, 4, etc.")
#9. count are integers
expect_error(traditionalModel(data=list(count=rbind(c(4.1,1,1),c(1,1,NA)),
count.type=rbind(c(1,1,2),c(1,2,NA))),
q=TRUE),
"All values in count should be integers.")
#9. count are integers
expect_error(traditionalModel(data=list(count=rbind(c(4.1,1,1),c(1,1,NA)),
count.type=rbind(c(1,1,2),c(1,2,NA))),
q=TRUE, family = 'gamma'),
"All values in count should be integers.")
#9. count are integers
expect_error(traditionalModel(data=list(count=rbind(c(4.1,1,1),c(1,1,NA)),
count.type=rbind(c(1,1,2),c(1,2,NA))),
q=TRUE, family = 'negbin'),
"All values in count should be integers.")
#10. count.type are integers
expect_error(traditionalModel(data=list(count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c(1.1,1,2),c(1,2,NA))),
q=TRUE),
"All values in count.type should be integers.")
test <- list(count=greencrabData$count[1:10,],
count.type=greencrabData$count.type[1:10,])
out <- traditionalModel(data=test,q=TRUE,n.chain=1,n.iter.burn=500,
n.iter.sample=500)
expect_type(sum(colMeans(rstan::extract(out,par='log_lik')$log_lik)), 'double')
sum(colMeans(rstan::extract(out,par='log_lik')$log_lik))
out <- traditionalModel(data=test,q=TRUE,family='gamma',n.chain=1,n.iter.burn=500,
n.iter.sample=500)
expect_type(sum(colMeans(rstan::extract(out,par='log_lik')$log_lik)), 'double')
sum(colMeans(rstan::extract(out,par='log_lik')$log_lik))
out
rstan::summary(out,pars='mu')
test <- list(count=greencrabData$count[1:10,])
out <- traditionalModel(data=test,family='gamma',n.chain=1,n.iter.burn=500,
n.iter.sample=500)
expect_type(sum(colMeans(rstan::extract(out,par='log_lik')$log_lik)), 'double')
out
rstan::summary(out,pars='mu')
out
count=greencrabData$count[1:10,]
View(count)
data <- greencrabData
'%>%' <- magrittr::`%>%`
#convert qPCR data to long format
qPCR_all <- as.data.frame(data$qPCR.N) %>%
dplyr::mutate(L=1:dim(data$qPCR.N)[1]) %>%
tidyr::pivot_longer(cols=!L,values_to='N') %>%
tidyr::drop_na()
qPCR.K_df <- as.data.frame(data$qPCR.K) %>%
dplyr::mutate(L=1:dim(data$qPCR.K)[1]) %>%
tidyr::pivot_longer(cols=!L,values_to='K') %>%
tidyr::drop_na()
qPCR_all$K <- qPCR.K_df$K
#convert count data to long format
count_all <- as.data.frame(data$count) %>%
dplyr::mutate(L=1:dim(data$count)[1]) %>%
tidyr::pivot_longer(cols=!L,values_to='count') %>%
tidyr::drop_na()
#options(buildtools.check = function(action) TRUE )
model <- rstan::stan_model('inst/stan/traditional_gamma.stan')
options(buildtools.check = function(action) TRUE )
options(buildtools.check = function(action) TRUE )
model <- rstan::stan_model('inst/stan/traditional_gamma.stan')
# traditional
out <- rstan::sampling(model,
data = list(
Nloc = length(unique(qPCR_all$L)),
C = nrow(count_all),
R = count_all$L,
E = count_all$count,
#nparams = length(q_names),
#mat = as.matrix(count_all[,q_names]),
control = list(adapt_delta = adapt_delta)
),
chains = 1,
thin = 1,
warmup = n.iter.burn,
iter = n.iter.burn + 1000,
init = init_trad(1,count_all)
)
out
rstan::summary(out,pars='mu')
#options(buildtools.check = function(action) TRUE )
model <- rstan::stan_model('inst/stan/traditional_gamma.stan')
# traditional
out <- rstan::sampling(model,
data = list(
Nloc = length(unique(qPCR_all$L)),
C = nrow(count_all),
R = count_all$L,
E = count_all$count,
#nparams = length(q_names),
#mat = as.matrix(count_all[,q_names]),
control = list(adapt_delta = adapt_delta)
),
chains = 1,
thin = 1,
warmup = n.iter.burn,
iter = n.iter.burn + 500,
init = init_trad(1,count_all)
)
#options(buildtools.check = function(action) TRUE )
model <- rstan::stan_model('inst/stan/traditional_gamma.stan')
# traditional
out <- rstan::sampling(model,
data = list(
Nloc = length(unique(qPCR_all$L)),
C = nrow(count_all),
R = count_all$L,
E = count_all$count,
#nparams = length(q_names),
#mat = as.matrix(count_all[,q_names]),
control = list(adapt_delta = adapt_delta)
),
chains = 1,
thin = 1,
warmup = n.iter.burn,
iter = n.iter.burn + 500,
init = init_trad(1,count_all)
)
out
rstan::summary(out,pars='mu')$summary
#options(buildtools.check = function(action) TRUE )
model <- rstan::stan_model('inst/stan/traditional_gamma.stan')
# traditional
out <- rstan::sampling(model,
data = list(
Nloc = length(unique(qPCR_all$L)),
C = nrow(count_all),
R = count_all$L,
E = count_all$count,
#nparams = length(q_names),
#mat = as.matrix(count_all[,q_names]),
control = list(adapt_delta = adapt_delta)
),
chains = 1,
thin = 1,
warmup = n.iter.burn,
iter = n.iter.burn + 500,
init = init_trad(1,count_all)
)
rstan::summary(out,pars='mu')$summary
pkgbuild::clean_dll()
pkgbuild::compile_dll()
devtools::load_all()
test <- list(qPCR.N=greencrabData$qPCR.N[1:10,],
qPCR.K=greencrabData$qPCR.K[1:10,],
count=greencrabData$count[1:10,],
count.type=greencrabData$count.type[1:10,])
out <- jointModel(data=test,q=FALSE,family='gamma',n.chain=1,n.iter.burn=500,
n.iter.sample=500)
sum(colMeans(rstan::extract(out,par='log_lik')$log_lik))
out
test$count
test$count[8,]
#options(buildtools.check = function(action) TRUE )
model <- rstan::stan_model('inst/stan/traditional_gamma.stan')
# traditional
out <- rstan::sampling(model,
data = list(
Nloc = length(unique(qPCR_all$L)),
C = nrow(count_all),
R = count_all$L,
E = count_all$count,
#nparams = length(q_names),
#mat = as.matrix(count_all[,q_names]),
control = list(adapt_delta = adapt_delta)
),
chains = 1,
thin = 1,
warmup = n.iter.burn,
iter = n.iter.burn + 500,
init = init_trad(1,count_all)
)
out
rstan::summary(out,pars='mu')$summary
#options(buildtools.check = function(action) TRUE )
model <- rstan::stan_model('inst/stan/joint_binary_gamma.stan')
out <- rstan::sampling(model,
data = list(
S = nrow(qPCR_all),
L = qPCR_all$L,
Nloc = length(unique(qPCR_all$L)),
N = qPCR_all$N,
K = qPCR_all$K,
C = nrow(count_all),
R = count_all$L,
E = count_all$count,
p10priors = c(mu_ln,sigma_ln),
#nparams = length(q_names),
#mat = as.matrix(count_all[,q_names]),
#nsitecov = length(cov)+1,
#mat_site = as.matrix(site_mat),
control = list(adapt_delta = adapt_delta)
),
chains = n.chain,
thin = 1,
warmup = n.iter.burn,
iter = n.iter.burn + n.iter.sample,
init = init_joint(n.chain,count_all)
)
out
pkgbuild::clean_dll()
pkgbuild::compile_dll()
devtools::load_all()
test <- list(qPCR.N=greencrabData$qPCR.N[1:10,],
qPCR.K=greencrabData$qPCR.K[1:10,],
count=greencrabData$count[1:10,],
count.type=greencrabData$count.type[1:10,])
out <- jointModel(data=test,q=FALSE,family='gamma',n.chain=1,n.iter.burn=500,
n.iter.sample=500)
sum(colMeans(rstan::extract(out,par='log_lik')$log_lik))
rstan::summary(out,pars='mu')$summary
out
out2 <- jointModel(data=test,q=FALSE,family='negbin',n.chain=1,n.iter.burn=500,
n.iter.sample=500)
out2
log(beta)
test <- list(qPCR.N=greencrabData$qPCR.N[1:10,],
qPCR.K=greencrabData$qPCR.K[1:10,],
count=greencrabData$count[1:10,],
count.type=greencrabData$count.type[1:10,])
out <- jointModel(data=test,q=FALSE,family='gamma',n.chain=1,n.iter.burn=500,
n.iter.sample=500)
devtools::load_all()
out <- jointModel(data=test,q=FALSE,family='gamma',n.chain=1,n.iter.burn=500,
n.iter.sample=500)
out
rstan::extract(out,par='log_lik')$log_lik
test_loglik <- rstan::extract(out,par='log_lik')$log_lik)
test_loglik <- rstan::extract(out,par='log_lik')$log_lik
dim(test_loglike)
dim(test_loglik)
test_loglik[,1]
test_loglik[,2]
test_loglik[,3]
test_loglik[,4]
test_loglik[,5]
dim(test_loglik)
test_loglik[,600]
data <- greencrabData
'%>%' <- magrittr::`%>%`
#convert qPCR data to long format
qPCR_all <- as.data.frame(data$qPCR.N) %>%
dplyr::mutate(L=1:dim(data$qPCR.N)[1]) %>%
tidyr::pivot_longer(cols=!L,values_to='N') %>%
tidyr::drop_na()
qPCR.K_df <- as.data.frame(data$qPCR.K) %>%
dplyr::mutate(L=1:dim(data$qPCR.K)[1]) %>%
tidyr::pivot_longer(cols=!L,values_to='K') %>%
tidyr::drop_na()
qPCR_all$K <- qPCR.K_df$K
#convert count data to long format
count_all <- as.data.frame(data$count) %>%
dplyr::mutate(L=1:dim(data$count)[1]) %>%
tidyr::pivot_longer(cols=!L,values_to='count') %>%
tidyr::drop_na()
#options(buildtools.check = function(action) TRUE )
model <- rstan::stan_model('inst/stan/joint_binary_gamma.stan')
options(buildtools.check = function(action) TRUE )
model <- rstan::stan_model('inst/stan/joint_binary_gamma.stan')
out <- rstan::sampling(model,
data = list(
S = nrow(qPCR_all),
L = qPCR_all$L,
Nloc = length(unique(qPCR_all$L)),
N = qPCR_all$N,
K = qPCR_all$K,
C = nrow(count_all),
R = count_all$L,
E = count_all$count,
p10priors = c(mu_ln,sigma_ln),
#nparams = length(q_names),
#mat = as.matrix(count_all[,q_names]),
#nsitecov = length(cov)+1,
#mat_site = as.matrix(site_mat),
control = list(adapt_delta = adapt_delta)
),
chains = n.chain,
thin = 1,
warmup = 500,
iter = 500 + 500,
init = init_joint(n.chain,count_all)
)
test_loglik2 <- rstan::extract(out,par='log_lik')$log_lik
dim(test_loglik2)
test_loglik2[,1]
rstan::summary(out,pars=c('alpha_gamma','beta_gamma'))
rstan::summary(out,pars=c('alpha_gamma','beta_gamma'))$summary
hist(rgamma(1000,0.03590560,0.40476924))
View(test)
dgamma(0,0.03590560,0.40476924)
dgamma(0,0.03590560,0.40476924,log=TRUE)
dgamma(0.000000000001,0.03590560,0.40476924,log=TRUE)
dgamma(0.000000000001,0.03590560,0.40476924)
dgamma(0.01,0.03590560,0.40476924,log=TRUE)
dgamma(1,0.03590560,0.40476924,log=TRUE)
dgamma(0.5,0.03590560,0.40476924,log=TRUE)
dgamma(0.2,0.03590560,0.40476924,log=TRUE)
dgamma(0.1,0.03590560,0.40476924,log=TRUE)
dgamma(0.01,0.03590560,0.40476924,log=TRUE)
dgamma(0.05,0.03590560,0.40476924,log=TRUE)
NA+0.1
0.1*rnorm(1,0,0.1)
0.1*rnorm(100,0,0.1)
0.1*rnorm(10,0,0.1)
rnorm(10,0.1,0.1)
rnorm(10,0.2,0.1)
rnorm(10,0.2,0.2)
0.1*rnorm(10,0,0.1)
0.1*rnorm(10,0,0.05)
0.1*rnorm(10,0,0.01)
rnorm(10,0,0.01)
rnorm(10,0.1,0.01)
rnorm(10,0.1,0.02)
rnorm(10,0.1,0.03)
rnorm(10,0.1,0.05)
dnorm(0,0.1,0.05)
hist(rnorm(1000,0.1,0.05))
hist(rnorm(1000,0.1,0.04))
hist(rnorm(1000,0.1,0.03))
hist(rnorm(1000,0.1,0.02))
devtools::load_all()
test <- list(qPCR.N=greencrabData$qPCR.N[1:10,],
qPCR.K=greencrabData$qPCR.K[1:10,],
count=greencrabData$count[1:10,]+rnorm(10,0.1,0.02),
count.type=greencrabData$count.type[1:10,])
out <- jointModel(data=test,q=TRUE,family='negbin',n.chain=1,n.iter.burn=500,
n.iter.sample=500)
test <- list(qPCR.N=greencrabData$qPCR.N[1:10,],
qPCR.K=greencrabData$qPCR.K[1:10,],
count=greencrabData$count[1:10,]+rnorm(10,0.1,0.02),
count.type=greencrabData$count.type[1:10,])
out <- jointModel(data=test,q=FALSE,family='gamma',n.chain=1,n.iter.burn=500,
n.iter.sample=500)
pkgbuild::clean_dll()
pkgbuild::compile_dll()
pkgbuild::check_build_tools(debug = TRUE)
install.packages('devtools')
install.packages("devtools")
devtools::load_all()
pkgbuild::check_build_tools(debug = TRUE)
pkgbuild::check_build_tools(debug = TRUE)
pkgbuild::check_build_tools(debug = TRUE)
options(buildtools.check = function(action) TRUE )
pkgbuild::compile_dll()
devtools::load_all()
test <- list(qPCR.N=greencrabData$qPCR.N[1:10,],
qPCR.K=greencrabData$qPCR.K[1:10,],
count=greencrabData$count[1:10,]+rnorm(10,0.1,0.02),
count.type=greencrabData$count.type[1:10,])
out <- jointModel(data=test,q=FALSE,family='gamma',n.chain=1,n.iter.burn=500,
n.iter.sample=500)
expect_type(sum(colMeans(rstan::extract(out,par='log_lik')$log_lik)), 'double')
sum(colMeans(rstan::extract(out,par='log_lik')$log_lik))
rstan::extract(out,par='log_lik')$log_lik
test <- list(qPCR.N=greencrabData$qPCR.N[1:10,],
qPCR.K=greencrabData$qPCR.K[1:10,],
count=greencrabData$count[1:10,]+rnorm(1,0.1,0.02),
count.type=greencrabData$count.type[1:10,])
test$count
greencrabData$count[1:10,]+rnorm(10,0.1,0.02)
greencrabData$count[1:10,]
out
rstan::extract(out,par='log_lik')$log_lik
rnorm(10,0.01,0.02)
rnorm(10,0.01,0.01)
hist(rnorm(1000,0.01,0.01))
hist(rnorm(1000,0.01,0.001))
hist(rnorm(1000,0.01,0.005))
hist(rnorm(1000,0.01,0.002))
hist(rnorm(1000,0.01,0.003))
hist(rnorm(1000,0.01,0.002))
rbind(c(1,1,1),c(1,1,1))+c(0.1,0.2,0.3,0.4,0.5,0.6)
greencrabData$count[1:10,]+rnorm(10,0.01,0.002)
dim(greencrabData$count[1:10,])
greencrabData$count[1:10,]+rnorm(4200,0.01,0.002)
hist(rnorm(1000,0.001,0.002))
hist(rnorm(1000,0.001,0.001))
hist(rnorm(1000,0.001,0.0005))
hist(rnorm(1000,0.001,0.0002))
hist(rnorm(1000,0.001,0.0003))
test <- list(qPCR.N=greencrabData$qPCR.N[1:10,],
qPCR.K=greencrabData$qPCR.K[1:10,],
count=greencrabData$count[1:10,]+rnorm(4200,0.001,0.0002),
count.type=greencrabData$count.type[1:10,])
out <- jointModel(data=test,q=FALSE,family='gamma',n.chain=1,n.iter.burn=500,
n.iter.sample=500)
sum(colMeans(rstan::extract(out,par='log_lik')$log_lik))
rstan::extract(out,par='log_lik')$log_lik
test$count
rstan::extract(out,par='log_lik')$log_lik)[1:10]
rstan::extract(out,par='log_lik')$log_lik[1:10]
rstan::extract(out,par='log_lik')$log_lik[1:100]
rstan::extract(out,par='log_lik')$log_lik[1:1000]
library(eDNAjoint)
library(devtools)
install_github('abigailkeller/eDNAjoint')
library(eDNAjoint)
remotes::install_github ("ropensci-review-tools/pkgcheck")
library (pkgcheck)
ctags_test ()
ctags_install()
ctags_test ()
library(pkgstats)
ctags_test ()
ctags_test ()
options(repos = c(
ropenscireviewtools = "https://ropensci-review-tools.r-universe.dev",
CRAN = "https://cloud.r-project.org"))
install.packages("srr")
library (srr)
options (repos = c (
ropenscireviewtools = "https://ropensci-review-tools.r-universe.dev",
CRAN = "https://cloud.r-project.org"
))
install.packages ("autotest")
x <- autotest_package ("<eDNAjoint>")
library(autotest)
x <- autotest_package ("<eDNAjoint>")
x <- autotest_package ("eDNAjoint")
x
help("autotest_package")
x <- autotest_package (package = "eDNAjoint", functions = "detectionCalculate")
x <- autotest_package (package = "eDNAjoint", functions = "traditionalModel")
