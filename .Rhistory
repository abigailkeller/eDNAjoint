expect_error(jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c(1,2,1),c(1,2,NA)),
site.cov=site.cov),
cov=c('var_a','var_b'),q=TRUE),
"site.cov should be numeric.")
#23. cov values match column names in site.cov
site.cov=cbind(c(0,1),c(0.4,-0.4))
expect_error(jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c(1,2,1),c(1,2,NA)),
site.cov=site.cov),
cov=c('var_a','var_b'),q=TRUE),
"cov values should be listed in the column names of site.cov in the data.")
#24. site.cov has same number of rows as qPCR.N and count, if present
site.cov=cbind(c(0,1,1),c(0.4,-0.4,1))
colnames(site.cov)=c('var_a','var_b')
expect_error(jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c(1,2,1),c(1,2,NA)),
site.cov=site.cov),
cov=c('var_a','var_b'),q=TRUE),
"The number of rows in site.cov matrix should match the number of rows in all other matrices.")
})
#16. phi priors is a vector of two numeric values
expect_error(jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA))),
phipriors=c(0,1)),
"phipriors should be a vector of two positive numeric values. ex. c\\(0.25,0.25\\)")
#15. p10 priors is a vector of two numeric values
expect_error(jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA))),
p10priors=c(0,20)),
"p10priors should be a vector of two positive numeric values. ex. c\\(1,20\\)")
devtools::load_all()
test_that("jointModel input checks work", {
#1. input tags are valid, q = FALSE, cov = FALSE
expect_error(jointModel(data=list(qPCR.n=rbind(c(1,1,1),c(1,1,NA)),
qPCR.k=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA)))),
"Data should include 'qPCR.N', 'qPCR.K', and 'count'.")
#2. input tags are valid, q = FALSE, cov = TRUE
site.cov=cbind(c(1,0),c(0.4,-0.4))
colnames(site.cov)=c('var_a','var_b')
expect_error(jointModel(data=list(qPCR.n=rbind(c(1,1,1),c(1,1,NA)),
qPCR.k=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA)),
site.cov=site.cov),
cov=c('var_a','var_b')),
"Data should include 'qPCR.N', 'qPCR.K', 'count', and 'site.cov'.")
#3. input tags are valid, q = TRUE, cov = FALSE
expect_error(jointModel(data=list(qPCR.n=rbind(c(1,1,1),c(1,1,NA)),
qPCR.k=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c(1,2,1),c(1,2,NA))),
q=TRUE),
"Data should include 'qPCR.N', 'qPCR.K', 'count', and 'count.type'.")
#4. input tags are valid, q = TRUE, cov = TRUE
site.cov=cbind(c(1,0),c(0.4,-0.4))
colnames(site.cov)=c('var_a','var_b')
expect_error(jointModel(data=list(qPCR.n=rbind(c(1,1,1),c(1,1,NA)),
qPCR.k=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c(1,2,1),c(1,2,NA)),
site.cov=site.cov),
cov=c('var_a','var_b'),q=TRUE),
"Data should include 'qPCR.N', 'qPCR.K', 'count', 'count.type', and 'site.cov'.")
#5. make sure dimensions of qPCR.N and qPCR.K are equal
expect_error(jointModel(data=list(qPCR.N=rbind(c(1,1,1,1),c(1,1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA)))),
"Dimensions of qPCR.N and qPCR.K do not match.")
#6. make sure dimensions of count and count.type are equal, if count.type is present
expect_error(jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c(1,2),c(1,2))),
q=TRUE),
"Dimensions of count and count.type do not match.")
#7. make sure number of rows in count = number of rows in qPCR.N and qPCR.K
expect_error(jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA),c(4,1,1)))),
"Number of sites \\(rows\\) in qPCR data and traditional survey count data do not match.")
#8. make sure all data is numeric -- if q == TRUE
expect_error(jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c('NA',2,2),c(1,2,2))),
q=TRUE),
"Data should be numeric.")
#9. make sure all data is numeric -- if q == FALSE
expect_error(jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,'NA')),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA)))),
"Data should be numeric.")
#10. make sure locations of NAs in count data match locations of NAs in count.type data
expect_error(jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c(NA,2,2),c(1,2,2))),
q=TRUE),
"Empty data cells \\(NA\\) in count data should match empty data cells \\(NA\\) in count.type data.")
#11. make sure locations of NAs in qPCR.N data match locations of NAs in qPCR.K data
expect_error(jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,NA,1)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA)))),
"Empty data cells \\(NA\\) in qPCR.N data should match empty data cells \\(NA\\) in qPCR.K data.")
#12. make sure family is either 'poisson', 'negbin', or 'gamma'
expect_error(jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA))),
family='normal'),
"Invalid family. Options include 'poisson', 'negbin', and 'gamma'.")
#13. p10 priors is a vector of two numeric values
expect_error(jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA))),
p10priors=c(1,1,2)),
"p10priors should be a vector of two positive numeric values. ex. c\\(1,20\\)")
#14. p10 priors is a vector of two numeric values
expect_error(jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA))),
p10priors='1,20'),
"p10priors should be a vector of two positive numeric values. ex. c\\(1,20\\)")
#15. p10 priors is a vector of two numeric values
expect_error(jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA))),
p10priors=c(0,20)),
"p10priors should be a vector of two positive numeric values. ex. c\\(1,20\\)")
#16. phi priors is a vector of two numeric values
expect_error(jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA))),
phipriors=c(0,1)),
"phipriors should be a vector of two positive numeric values. ex. c\\(0.25,0.25\\)")
#17. the smallest count.type is 1
expect_error(jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c(0,1,2),c(1,2,NA))),
q=TRUE),
"The first gear type should be referenced as 1 in count.type. Subsequent gear types should be referenced 2, 3, 4, etc.")
#18. count are integers
expect_error(jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4.1,1,1),c(1,1,NA)),
count.type=rbind(c(1,1,2),c(1,2,NA))),
q=TRUE, family = 'negbin'),
"All values in count should be integers. Use family = 'gamma' if count is continuous.")
#19. qPCR.N are integers
expect_error(jointModel(data=list(qPCR.N=rbind(c(0.99,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c(1,1,2),c(1,2,NA))),
q=TRUE),
"All values in qPCR.N should be integers.")
#20. qPCR.K are integers
expect_error(jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3.1,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c(1,1,2),c(1,2,NA))),
q=TRUE),
"All values in qPCR.K should be integers.")
#21. count.type are integers
expect_error(jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c(1.1,1,2),c(1,2,NA))),
q=TRUE),
"All values in count.type should be integers.")
#22. site.cov is numeric, if present
site.cov=cbind(c('high','low'),c(0.4,-0.4))
colnames(site.cov)=c('var_a','var_b')
expect_error(jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c(1,2,1),c(1,2,NA)),
site.cov=site.cov),
cov=c('var_a','var_b'),q=TRUE),
"site.cov should be numeric.")
#23. cov values match column names in site.cov
site.cov=cbind(c(0,1),c(0.4,-0.4))
expect_error(jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c(1,2,1),c(1,2,NA)),
site.cov=site.cov),
cov=c('var_a','var_b'),q=TRUE),
"cov values should be listed in the column names of site.cov in the data.")
#24. site.cov has same number of rows as qPCR.N and count, if present
site.cov=cbind(c(0,1,1),c(0.4,-0.4,1))
colnames(site.cov)=c('var_a','var_b')
expect_error(jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c(1,2,1),c(1,2,NA)),
site.cov=site.cov),
cov=c('var_a','var_b'),q=TRUE),
"The number of rows in site.cov matrix should match the number of rows in all other matrices.")
})
#11. phi priors is a vector of two numeric values
expect_error(traditionalModel(data=list(count=rbind(c(4,1,1),c(1,1,NA)))
phipriors=c(0,1)),
#11. phi priors is a vector of two numeric values
expect_error(traditionalModel(data=list(count=rbind(c(4,1,1),c(1,1,NA))),
phipriors=c(0,1)),
"phipriors should be a vector of two positive numeric values. ex. c\\(0.25,0.25\\)")
devtools::load_all()
test_that("traditionalModel input checks work", {
#1. input tags are valid, q = TRUE
expect_error(traditionalModel(data=list(Count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c(1,2,1),c(1,2,NA))),q=TRUE),
"Data should include 'count' and 'count.type'.")
#2. input tags are valid, q = FALSE
expect_error(traditionalModel(data=list(Count=rbind(c(4,1,1),c(1,1,NA)))),
"Data should include 'count'.")
#3. make sure dimensions of count and count.type are equal, if count.type is present
expect_error(traditionalModel(data=list(count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c(1,2),c(1,2))),
q=TRUE),
"Dimensions of count and count.type do not match.")
#4. make sure all data is numeric -- if q == TRUE
expect_error(traditionalModel(data=list(count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c('NA',2,2),c(1,2,2))),
q=TRUE),
"Data should be numeric.")
#5. make sure all data is numeric -- if q == FALSE
expect_error(traditionalModel(data=list(count=rbind(c(4,1,1),c(1,1,'NA')))),
"Data should be numeric.")
#6. make sure locations of NAs in count data match locations of NAs in count.type data
expect_error(traditionalModel(data=list(count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c(NA,2,2),c(1,2,2))),
q=TRUE),
"Empty data cells \\(NA\\) in count data should match empty data cells \\(NA\\) in count.type data.")
#7. make sure family is either 'poisson', 'negbin', or 'gamma'
expect_error(traditionalModel(data=list(count=rbind(c(4,1,1),c(1,1,NA))),
family='normal'),
"Invalid family. Options include 'poisson', 'negbin', or 'gamma'.")
#8. the smallest count.type is 1
expect_error(traditionalModel(data=list(count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c(0,1,2),c(1,2,NA))),
q=TRUE),
"The first gear type should be referenced as 1 in count.type. Subsequent gear types should be referenced 2, 3, 4, etc.")
#9. count are integers
expect_error(traditionalModel(data=list(count=rbind(c(4.1,1,1),c(1,1,NA)),
count.type=rbind(c(1,1,2),c(1,2,NA))),
q=TRUE, family = 'negbin'),
"All values in count should be integers.")
#10. count.type are integers
expect_error(traditionalModel(data=list(count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c(1.1,1,2),c(1,2,NA))),
q=TRUE),
"All values in count.type should be integers.")
#11. phi priors is a vector of two numeric values
expect_error(traditionalModel(data=list(count=rbind(c(4,1,1),c(1,1,NA))),
phipriors=c(0,1)),
"phipriors should be a vector of two positive numeric values. ex. c\\(0.25,0.25\\)")
})
model1 <- jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA))))
type(model1)
is(model1,'stanfit')
model1 <- jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA))),
multicore=FALSE)
data <- data("greencrabData")
model1 = traditionalModel(data=greencrabData, family='negbin')
model1 = traditionalModel(data=greencrabData, family='negbin',multicore=FALSE,
n.chain=2,n.iter.burn=0,n.iter.sample=200)
model2 = jointModel(data=greencrabData, family='negbin',multicore=FALSE,
n.chain=2,n.iter.burn=0,n.iter.sample=200)
test <- c(model1,model2)
is(test,'list')
test <- as.matrix(model1)
# 1. Check that model inputs are a list
expect_error(jointSelect(c(as.matrix(model1),as.matrix(model2))),
"Model fits in modelfits input must be of class 'stanfit'.")
test <- c(as.matrix(model1),as.matrix(model2))
is(test,'list')
test <- list(as.matrix(model1),as.matrix(model2))
is(test,'list')
# 1. Check that model inputs are a list
expect_error(jointSelect(list(as.matrix(model1),as.matrix(model2))),
"Model fits in modelfits input must be of class 'stanfit'.")
# 1. Check that model inputs are a list
expect_error(jointSelect(c(model1model2)),
"modelfits must be a list.")
# 1. Check that model inputs are a list
expect_error(jointSelect(c(model1,model2)),
"modelfits must be a list.")
# 1. Check that model inputs are a list
expect_error(jointSelect(c(model1,model1)),
"modelfits must be a list.")
# 1. Check that model inputs are a list
expect_error(jointSelect(c(as.matrix(model1),as.matrix(model2)))),
# 1. Check that model inputs are a list
expect_error(jointSelect(c(as.matrix(model1),as.matrix(model2))),
"modelfits must be a list.")
expect_error(jointSelect(list(as.matrix(model1),as.matrix(model2))),
"Model fits in modelfits input must be of class 'stanfit'.")
# 3. Check that all models are of the same type
expect_error(jointSelect(list(model1,model2)),
"All modelfits must be fit with either jointModel\\(\\) or all with traditionalModel\\(\\).")
#create model output
test <- list(qPCR.N=greencrabData$qPCR.N[1:10,],
qPCR.K=greencrabData$qPCR.K[1:10,],
count=greencrabData$count[1:10,],
count.type=greencrabData$count.type[1:10,])
out <- jointModel(data=test,q=TRUE,family='negbin',n.chain=1,n.iter.burn=500,
n.iter.sample=500)
# run traditional model to do tests with
data <- data("greencrabData")
out = traditionalModel(data=greencrabData, family='negbin',multicore=FALSE,
n.chain=2,n.iter.burn=0,n.iter.sample=200)
out = traditionalModel(data=greencrabData, family='negbin',multicore=FALSE,
n.chain=2,n.iter.burn=50,n.iter.sample=200)
#1. make sure model fit is of class stanfit
data <- data.frame(y=c(1,2,3),x=c(1,2,3))
lm_out <- lm(y ~ x, data=data)
expect_error(summarize(lm_out),
"modelfit must be of class 'stanfit'.")
expect_error(jointSummarize(lm_out),
"modelfit must be of class 'stanfit'.")
#2. make sure probs is a numeric vector
expect_error(jointSummarize(out,probs=c('95%')),
"probs must be a numeric vector.")
#3. make sure all values of probs are between 0 and 1
expect_error(jointSummarize(out,probs=c(5,95)),
"probs must be between 0 and 1.")
#4. make sure par is a character vector
expect_error(jointSummarize(out,par=c(1,2,3)),
"par must be a character vector.")
#5. make sure model fit contains all par input
expect_error(jointSummarize(out,par='alpha'),
"modelfit must contain all selected parameters: alpha")
devtools::load_all()
install.packages('bayestestR')
install.packages('loo')
install.packages('RcppParallel')
install.packages('rstan')
install.packages('rstantool')
install.packages('rstantools')
devtools::load_all()
# run joint model to do tests with
data <- data("greencrabData")
out = jointModel(data=greencrabData, family='negbin',multicore=FALSE,
n.chain=2,n.iter.burn=50,n.iter.sample=200)
install.packages('rlist')
out = jointModel(data=greencrabData, family='negbin',multicore=FALSE,
n.chain=2,n.iter.burn=50,n.iter.sample=200)
model1 <- jointModel(data=gobyData, cov=c('Filter_time','Salinity'),multicore=FALSE,
n.chain=2,n.iter.burn=50,n.iter.sample=200)
model2 <- traditionalModel(data=gobyData,multicore=FALSE,
n.chain=2,n.iter.burn=50,n.iter.sample=200)
model3 <- jointModel(data=greencrabData,family='negbin',multicore=FALSE,
n.chain=2,n.iter.burn=50,n.iter.sample=200)
#1. make sure model fit is of class stanfit
expect_error(muCritical(as.matrix(model1), cov.val = c(0,0)),
"modelfit must be of class 'stanfit'.")
#2. make sure ci is valid
expect_error(muCritical(model1, ci = 1, cov.val = c(0,0)),
"ci must be a numeric value >0 and <1.")
#3. make sure model fit contains p10 parameter
expect_error(muCritical(model2),
"modelfit must be contain 'p10' parameter.")
#4. if modelfit contains alpha, cov.val must be provided
expect_error(muCritical(model1),
"If modelfit contains site-level covariates, values must be provided for cov.val")
#5. cov.val is numeric, if provided
expect_error(muCritical(model1, cov.val=c(TRUE,TRUE)),
"cov.val must be a numeric vector")
#6. Only include input cov.val if covariates are included in model
expect_error(muCritical(model3, cov.val=c(0,0)),
"cov.val must be 'None' if the model does not contain site-level covariates.")
#7. Only include input cov.val if covariates are included in model
expect_error(muCritical(model1, cov.val=c(0,0,0)),
"cov.val must be of the same length as the number of non-intercept site-level coefficients in the model.")
gobyData$qPCR.N
#1. make sure model fit is of class stanfit
expect_error(detectionCalculate(as.matrix(model1), mu = c(0.1, 0.5), cov.val = c(0,0)),
"modelfit must be of class 'stanfit'.")
detectionCalculate(model3,mu=0)
devtools::load_all()
#2. make sure ci is valid
expect_error(detectionCalculate(model1, mu = c('0', 0.5), cov.val = c(0,0)),
"mu must be a numeric vector of positive values")
devtools::load_all()
#2. make sure mu is a numeric vector
expect_error(detectionCalculate(model1, mu = c('0', 0.5), cov.val = c(0,0)),
"mu must be a numeric vector of positive values")
devtools::load_all()
#2. make sure mu is a numeric vector
expect_error(detectionCalculate(model1, mu = c('0', 0.5), cov.val = c(0,0)),
"mu must be a numeric vector of positive values")
#3. make sure mu is a numeric vector of positive values
expect_error(detectionCalculate(model1, mu = c(0, 0.5), cov.val = c(0,0)),
"mu must be a numeric vector of positive values")
#4. make sure probability is a numeric value between 0 and 1
expect_error(detectionCalculate(model1, mu = c(0, 0.5), cov.val = c(0,0), probability = 1),
"mu must be a numeric vector of positive values")
#5. cov.val is numeric, if provided
expect_error(detectionCalculate(model1, mu = c(0, 0.5), cov.val = c('0',0)),
"mu must be a numeric vector of positive values")
#1. make sure model fit is of class stanfit
expect_error(detectionCalculate(as.matrix(model1), mu = c(0.1, 0.5), cov.val = c(0,0)),
"modelfit must be of class 'stanfit'.")
#2. make sure ci is valid
expect_error(detectionCalculate(model1, mu = c('0', 0.5), cov.val = c(0,0)),
"mu must be a numeric vector of positive values")
#3. make sure mu is a numeric vector of positive values
expect_error(detectionCalculate(model1, mu = c(0, 0.5), cov.val = c(0,0)),
"mu must be a numeric vector of positive values")
#4. make sure probability is a numeric value between 0 and 1
expect_error(detectionCalculate(model1, mu = c(0.1, 0.5), cov.val = c(0,0), probability = 1),
"mu must be a numeric vector of positive values")
#4. make sure probability is a numeric value between 0 and 1
expect_error(detectionCalculate(model1, mu = c(0.1, 0.5), cov.val = c(0,0), probability = 1),
"probability must be a numeric value between 0 and 1")
#4. make sure probability is a numeric value between 0 and 1
expect_error(detectionCalculate(model1, mu = c(0.1, 0.5), cov.val = c(0,0), probability = 1.05),
"probability must be a numeric value between 0 and 1")
#5. cov.val is numeric, if provided
expect_error(detectionCalculate(model1, mu = c(0.1, 0.5), cov.val = c('0',0)),
"mu must be a numeric vector of positive values")
#5. cov.val is numeric, if provided
expect_error(detectionCalculate(model1, mu = c(0.1, 0.5), cov.val = c('0',0)),
"cov.val must be a numeric vector")
#6. Only include input cov.val if covariates are included in model
expect_error(detectionCalculate(model3, mu = c(0.1, 0.5), cov.val = c(0,0)),
"cov.val must be 'None' if the model does not contain site-level covariates.")
#7. Input cov.val is the same length as the number of estimated covariates.
expect_error(detectionCalculate(model1, mu = c(0.1, 0.5), cov.val = c(0,0,0)),
"cov.val must be of the same length as the number of non-intercept site-level coefficients in the model.")
detectionCalculate(model1, mu = c(0.1, 0.5), cov.val = c(0,0), probability = 1)
devtools::load_all()
devtools::load_all()
detectionPlot(model1, mu.min = 0.1, cov.val = c(0,0))
detectionPlot(model1, mu.min = 0.1, mu.max = 1)
devtools::load_all()
#8. If covariates are in model, cov.val must be provided
expect_error(detectionCalculate(model1, mu = c(0.1, 0.5)),
"cov.val must be provided if the model contains site-level covariates.")
#1. make sure model fit is of class stanfit
expect_error(detectionPlot(as.matrix(model1), mu.min = 0.1, mu.max = 1, cov.val = c(0,0)),
"modelfit must be of class 'stanfit'.")
#2. make sure mu.min is a numeric value
expect_error(detectionPlot(model1, mu.min = '0.1', mu.max = 1, cov.val = c(0,0)),
"mu.min must be a numeric value greater than 0")
#3. make sure mu.min is a numeric value
expect_error(detectionPlot(model1, mu.min = 0, mu.max = 1, cov.val = c(0,0)),
"mu.min must be a numeric value greater than 0")
#4. make sure mu.max is a numeric value
expect_error(detectionPlot(model1, mu.min = 0.1, mu.max = '1', cov.val = c(0,0)),
"mu.max must be a numeric value greater than mu.min")
#5. make sure mu.max is a numeric value
expect_error(detectionPlot(model1, mu.min = 0.1, mu.max = 0.1, cov.val = c(0,0)),
"mu.max must be a numeric value greater than mu.min")
#6. make sure mu.max is a numeric value
expect_error(detectionPlot(model1, mu.min = 0.1, mu.max = 1, cov.val = c(0,0), probability = 1.1),
"probability must be a numeric value between 0 and 1")
#7. cov.val is numeric, if provided
expect_error(detectionPlot(model1, mu.min = 0.1, mu.max = 1, cov.val = c(0,'0')),
"cov.val must be a numeric vector")
#8. Only include input cov.val if covariates are included in model
expect_error(detectionPlot(model2, mu.min = 0.1, mu.max = 1, cov.val = c(0,0)),
"cov.val must be 'None' if the model does not contain site-level covariates.")
#9. Input cov.val is the same length as the number of estimated covariates.
expect_error(detectionPlot(model1, mu.min = 0.1, mu.max = 1, cov.val = c(0,0,0)),
"cov.val must be of the same length as the number of non-intercept site-level coefficients in the model.")
#10. If covariates are in model, cov.val must be provided
expect_error(detectionPlot(model1, mu.min = 0.1, mu.max = 1),
"cov.val must be provided if the model contains site-level covariates.")
devtools::document()
roxygen2::roxygenise()
devtools::install()
options (repos = c (
ropenscireviewtools = "https://ropensci-review-tools.r-universe.dev",
CRAN = "https://cloud.r-project.org"
))
install.packages ("pkgcheck")
library (pkgcheck)
Sys.setenv ("GITHUB_TOKEN" = "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")
library (pkgcheck)
mydir <- file.path (tempdir (), "srr-demo")
gert::git_clone ("https://github.com/abigailkeller/eDNAjoint", path = mydir)
x <- pkgcheck (mydir)
install.packages ("pkgstats")
install.packages("pkgstats")
options (repos = c (
ropenscireviewtools = "https://ropensci-review-tools.r-universe.dev",
CRAN = "https://cloud.r-project.org"
))
remotes::install_github ("ropensci-review-tools/pkgstats")
pak::pkg_install ("ropensci-review-tools/pkgstats")
library (pkgstats)
ctags_test ()
ctags_install()
x <- pkgcheck (mydir)
library (pkgcheck)
mydir <- file.path (tempdir (), "srr-demo")
gert::git_clone ("https://github.com/abigailkeller/eDNAjoint", path = mydir)
x <- pkgcheck (mydir)
