mu_trad_1 <- as.numeric(na.omit(rowMeans(data$count,na.rm=TRUE))),
q <- as.vector(stats::runif(length(q_names),0.01,1)),
log_p10 <- stats::runif(1,log(0.0001),log(0.08)),
beta <- 0.5
)
names(A[[i]]) <- c('mu_trad_1','q','log_p10','beta')
}
}
return(A)
}
# get initial values
if(isCatch_type(q)){
inits <- get_inits(n.chain,qPCR_all,initial_values,cov,data,q_names)
} else {
inits <- get_inits(n.chain,qPCR_all,initial_values,cov,data)
}
inits
q
q <- TRUE
# get initial values
if(isCatch_type(q)){
inits <- get_inits(n.chain,qPCR_all,initial_values,cov,data,q_names)
} else {
inits <- get_inits(n.chain,qPCR_all,initial_values,cov,data)
}
inits
# helper function
# joint model, catchability coefficient, no site covariates
A <- list()
if(all(!is.null(initial_values))){
for(i in 1:n.chain){
A[[i]] <- list(
if('mu' %in% names(initial_values[[i]])){
mu_trad_1 <- initial_values[[i]]$mu
} else {
mu_trad_1 <- as.numeric(na.omit(rowMeans(data$count,na.rm=TRUE)))
},
if('q' %in% names(initial_values[[i]])){
q <- as.data.frame(initial_values[[i]]$q)
} else {
q <- as.data.frame(stats::runif(length(q_names),0.01,1))
},
if('p10' %in% names(initial_values[[i]])){
log_p10 <- log(initial_values[[i]]$p10)
} else {
log_p10 <- stats::runif(1,log(0.0001),log(0.08))
},
if('beta' %in% names(initial_values[[i]])){
beta <- initial_values[[i]]$beta
} else {
beta <- 0.5
}
)
names(A[[i]]) <- c('mu_trad_1','q','log_p10','beta')
}
} else {
for(i in 1:n.chain){
A[[i]] <- list(
mu_trad_1 <- as.numeric(na.omit(rowMeans(data$count,na.rm=TRUE))),
q <- as.data.frame(stats::runif(length(q_names),0.01,1)),
log_p10 <- stats::runif(1,log(0.0001),log(0.08)),
beta <- 0.5
)
names(A[[i]]) <- c('mu_trad_1','q','log_p10','beta')
}
}
inits
# run model
out <- rstan::sampling(
model,
data = model_data,
cores = cores,
seed = SEED,
#' @srrstats {G2.4,G2.4a} explicit conversion to
#'   integers for sampling arguments
chains = as.integer(n.chain),
thin = as.integer(thin),
warmup = as.integer(n.iter.burn),
iter = (
as.integer(n.iter.burn) + as.integer(n.iter.sample)
),
init = inits,
refresh = ifelse(verbose == TRUE,500,0)
)
inits
data
data
length(data)
data$count
dim(data$count)
rowMeans(data$count,na.rm=TRUE)
na.omit(rowMeans(data$count,na.rm=TRUE))
as.numeric(na.omit(rowMeans(data$count,na.rm=TRUE)))
initial_values
mu
# params
mu <- rlnorm(nsite, meanlog = log(1), sdlog = 1)
mu
# initial values
initial_values <- list()
initial_values[[1]] <- list(
mu = mu,
p10 = exp(log_p10),
beta = beta,
phi = phi,
q = q
)
names(initial_values[[1]]) <- c('mu','p10','beta','phi','q')
initial_values
get_inits <- function(n.chain,qPCR_all,initial_values,cov,data,q_names=NULL){
if(!is.null(cov)){
if(!is.null(q_names)){
inits <- init_joint_cov_catchability(n.chain,qPCR_all,q_names,cov,
initial_values,data)
} else {
inits <- init_joint_cov(n.chain,qPCR_all,cov,initial_values,data)
}
} else {
if(!is.null(q_names)){
inits <- init_joint_catchability(n.chain,qPCR_all,q_names,
initial_values,data)
} else {
inits <- init_joint(n.chain,qPCR_all,initial_values,data)
}
}
return(inits)
}
init_joint_cov <- function(n.chain,qPCR_all,cov,initial_values,data){
# helper function
# joint model, catchability coefficient, site covariates
A <- list()
if(all(!is.null(initial_values))){
for(i in 1:n.chain){
A[[i]] <- list(
if('mu' %in% names(initial_values[[i]])){
mu_trad <- initial_values[[i]]$mu
} else {
mu_trad <- as.numeric(na.omit(rowMeans(data$count,na.rm=TRUE)))
},
if('p10' %in% names(initial_values[[i]])){
log_p10 <- log(initial_values[[i]]$p10)
} else {
log_p10 <- stats::runif(1,log(0.0001),log(0.08))
},
if('alpha' %in% names(initial_values[[i]])){
alpha <- initial_values[[i]]$alpha
} else {
alpha <- rep(0.1,length(cov)+1)
}
)
names(A[[i]]) <- c('mu_trad','log_p10','alpha')
}
} else {
for(i in 1:n.chain){
A[[i]] <- list(
mu_trad <- as.numeric(na.omit(rowMeans(data$count,na.rm=TRUE))),
log_p10 <- stats::runif(1,log(0.0001),log(0.08)),
alpha <- rep(0.1,length(cov)+1)
)
names(A[[i]]) <- c('mu_trad','log_p10','alpha')
}
}
return(A)
}
init_joint_cov_catchability <- function(n.chain,qPCR_all,q_names,cov,
initial_values,data){
# helper function
# joint model, catchability coefficient, site covariates
A <- list()
if(all(!is.null(initial_values))){
for(i in 1:n.chain){
A[[i]] <- list(
if('mu' %in% names(initial_values[[i]])){
mu_trad_1 <- initial_values[[i]]$mu
} else {
mu_trad_1 <- as.numeric(na.omit(rowMeans(data$count,na.rm=TRUE)))
},
if('q' %in% names(initial_values[[i]])){
q <- as.data.frame(initial_values[[i]]$q)
} else {
q <- as.data.frame(stats::runif(length(q_names),0.01,1))
},
if('p10' %in% names(initial_values[[i]])){
log_p10 <- log(initial_values[[i]]$p10)
} else {
log_p10 <- stats::runif(1,log(0.0001),log(0.08))
},
if('alpha' %in% names(initial_values[[i]])){
alpha <- initial_values[[i]]$alpha
} else {
alpha <- rep(0.1,length(cov)+1)
}
)
names(A[[i]]) <- c('mu_trad_1','q','log_p10','alpha')
}
} else {
for(i in 1:n.chain){
A[[i]] <- list(
mu_trad <- as.numeric(na.omit(rowMeans(data$count,na.rm=TRUE))),
q <- as.data.frame(stats::runif(length(q_names),0.01,1)),
log_p10 <- stats::runif(1,log(0.0001),log(0.08)),
alpha <- rep(0.1,length(cov)+1)
)
names(A[[i]]) <- c('mu_trad_1','q','log_p10','alpha')
}
}
return(A)
}
init_joint_catchability <- function(n.chain,qPCR_all,q_names,initial_values,
data){
# helper function
# joint model, catchability coefficient, no site covariates
A <- list()
if(all(!is.null(initial_values))){
for(i in 1:n.chain){
A[[i]] <- list(
if('mu' %in% names(initial_values[[i]])){
mu_trad_1 <- initial_values[[i]]$mu
} else {
mu_trad_1 <- as.numeric(na.omit(rowMeans(data$count,na.rm=TRUE)))
},
if('q' %in% names(initial_values[[i]])){
q <- as.data.frame(initial_values[[i]]$q)
} else {
q <- as.data.frame(stats::runif(length(q_names),0.01,1))
},
if('p10' %in% names(initial_values[[i]])){
log_p10 <- log(initial_values[[i]]$p10)
} else {
log_p10 <- stats::runif(1,log(0.0001),log(0.08))
},
if('beta' %in% names(initial_values[[i]])){
beta <- initial_values[[i]]$beta
} else {
beta <- 0.5
}
)
names(A[[i]]) <- c('mu_trad_1','q','log_p10','beta')
}
} else {
for(i in 1:n.chain){
A[[i]] <- list(
mu_trad_1 <- as.numeric(na.omit(rowMeans(data$count,na.rm=TRUE))),
q <- as.data.frame(stats::runif(length(q_names),0.01,1)),
log_p10 <- stats::runif(1,log(0.0001),log(0.08)),
beta <- 0.5
)
names(A[[i]]) <- c('mu_trad_1','q','log_p10','beta')
}
}
return(A)
}
init_joint <- function(n.chain,qPCR_all,initial_values,data){
# helper function
# joint model, no catchability coefficient, no site covariates
A <- list()
if(all(!is.null(initial_values))){
for(i in 1:n.chain){
A[[i]] <- list(
if('mu' %in% names(initial_values[[i]])){
mu_trad <- initial_values[[i]]$mu
} else {
mu_trad <- as.numeric(na.omit(rowMeans(data$count,na.rm=TRUE)))
},
if('p10' %in% names(initial_values[[i]])){
log_p10 <- log(initial_values[[i]]$p10)
} else {
log_p10 <- stats::runif(1,log(0.0001),log(0.08))
},
if('beta' %in% names(initial_values[[i]])){
beta <- initial_values[[i]]$beta
} else {
beta <- 0.5
}
)
names(A[[i]]) <- c('mu_trad','log_p10','beta')
}
} else {
for(i in 1:n.chain){
A[[i]] <- list(
mu_trad <- as.numeric(na.omit(rowMeans(data$count,na.rm=TRUE))),
log_p10 <- stats::runif(1,log(0.0001),log(0.08)),
beta <- 0.5
)
names(A[[i]]) <- c('mu_trad','log_p10','beta')
}
}
return(A)
}
q
q <- TRUE
# get initial values
if(isCatch_type(q)){
inits <- get_inits(n.chain,qPCR_all,initial_values,cov,data,q_names)
} else {
inits <- get_inits(n.chain,qPCR_all,initial_values,cov,data)
}
inits
# run model
out <- rstan::sampling(
model,
data = model_data,
cores = cores,
seed = SEED,
#' @srrstats {G2.4,G2.4a} explicit conversion to
#'   integers for sampling arguments
chains = as.integer(n.chain),
thin = as.integer(thin),
warmup = as.integer(n.iter.burn),
iter = (
as.integer(n.iter.burn) + as.integer(n.iter.sample)
),
init = inits,
refresh = ifelse(verbose == TRUE,500,0)
)
inits
length(unique(qPCR_all_trad$L))
length(unique(qPCR_all_dna$L))
qPCR_all_trad$L_unique
data$count
dim(data$count)
length(unique(qPCR_all_dna$L))
length(unique(qPCR_all_trad$L))
data$count
rowMeans(data$count,na.rm=TRUE)
as.numeric(na.omit(rowMeans(data$count,na.rm=TRUE)))
mu
mu[c(1,3,5-20)]
mu[c(1,3,5:20)]
# initial values
initial_values <- list()
initial_values[[1]] <- list(
mu = mu[c(1,3,5:20)],
p10 = exp(log_p10),
beta = beta,
phi = phi,
q = q
)
names(initial_values[[1]]) <- c('mu','p10','beta','phi','q')
# run model
out <- rstan::sampling(
model,
data = model_data,
cores = cores,
seed = SEED,
#' @srrstats {G2.4,G2.4a} explicit conversion to
#'   integers for sampling arguments
chains = as.integer(n.chain),
thin = as.integer(thin),
warmup = as.integer(n.iter.burn),
iter = (
as.integer(n.iter.burn) + as.integer(n.iter.sample)
),
init = inits,
refresh = ifelse(verbose == TRUE,500,0)
)
q
# get initial values
if(isCatch_type(q)){
inits <- get_inits(n.chain,qPCR_all,initial_values,cov,data,q_names)
} else {
inits <- get_inits(n.chain,qPCR_all,initial_values,cov,data)
}
inits
# run model
out <- rstan::sampling(
model,
data = model_data,
cores = cores,
seed = SEED,
#' @srrstats {G2.4,G2.4a} explicit conversion to
#'   integers for sampling arguments
chains = as.integer(n.chain),
thin = as.integer(thin),
warmup = as.integer(n.iter.burn),
iter = (
as.integer(n.iter.burn) + as.integer(n.iter.sample)
),
init = inits,
refresh = ifelse(verbose == TRUE,500,0)
)
rstan::summary(fit)
rstan::summary(out)
help(rstan::summary)
help(summany)
help(summary)
jointSummarize(out)
test <- rstan::summary(out, pars = c('mu_trad_1','log_p10'))
test
test <- rstan::summary(out, pars = c('mu_trad_1','log_p10'))$summary
test
test <- rstan::summary(out, pars = c('mu_trad_1','log_p10','mu','p10'))$summary
test
inits
init_joint_catchability <- function(n.chain,qPCR_all,q_names,initial_values,
data){
# helper function
# joint model, catchability coefficient, no site covariates
A <- list()
if(all(!is.null(initial_values))){
for(i in 1:n.chain){
A[[i]] <- list(
if('mu' %in% names(initial_values[[i]])){
mu_trad_1 <- initial_values[[i]]$mu
} else {
mu_trad_1 <- as.numeric(na.omit(rowMeans(data$count,na.rm=TRUE)))
},
if('q' %in% names(initial_values[[i]])){
q_trans <- as.data.frame(initial_values[[i]]$q)
} else {
q_trans <- as.data.frame(stats::runif(length(q_names),0.01,1))
},
if('p10' %in% names(initial_values[[i]])){
log_p10 <- log(initial_values[[i]]$p10)
} else {
log_p10 <- stats::runif(1,log(0.0001),log(0.08))
},
if('beta' %in% names(initial_values[[i]])){
beta <- initial_values[[i]]$beta
} else {
beta <- 0.5
}
)
names(A[[i]]) <- c('mu_trad_1','q_trans','log_p10','beta')
}
} else {
for(i in 1:n.chain){
A[[i]] <- list(
mu_trad_1 <- as.numeric(na.omit(rowMeans(data$count,na.rm=TRUE))),
q_trans <- as.data.frame(stats::runif(length(q_names),0.01,1)),
log_p10 <- stats::runif(1,log(0.0001),log(0.08)),
beta <- 0.5
)
names(A[[i]]) <- c('mu_trad_1','q_trans','log_p10','beta')
}
}
return(A)
}
# get initial values
if(isCatch_type(q)){
inits <- get_inits(n.chain,qPCR_all,initial_values,cov,data,q_names)
} else {
inits <- get_inits(n.chain,qPCR_all,initial_values,cov,data)
}
inits
q
q <- 2
# get initial values
if(isCatch_type(q)){
inits <- get_inits(n.chain,qPCR_all,initial_values,cov,data,q_names)
} else {
inits <- get_inits(n.chain,qPCR_all,initial_values,cov,data)
}
inits
q
q <- TRUE
q <- 2
# initial values
initial_values <- list()
initial_values[[1]] <- list(
mu = mu[c(1,3,5:20)],
p10 = exp(log_p10),
beta = beta,
phi = phi,
q = q
)
names(initial_values[[1]]) <- c('mu','p10','beta','phi','q')
initial_values
q
q <- TRUE
# get initial values
if(isCatch_type(q)){
inits <- get_inits(n.chain,qPCR_all,initial_values,cov,data,q_names)
} else {
inits <- get_inits(n.chain,qPCR_all,initial_values,cov,data)
}
inits
# run model
out <- rstan::sampling(
model,
data = model_data,
cores = cores,
seed = SEED,
#' @srrstats {G2.4,G2.4a} explicit conversion to
#'   integers for sampling arguments
chains = as.integer(n.chain),
thin = as.integer(thin),
warmup = as.integer(n.iter.burn),
iter = (
as.integer(n.iter.burn) + as.integer(n.iter.sample)
),
init = inits,
refresh = ifelse(verbose == TRUE,500,0)
)
jointSummarize(out)
# run model
out <- rstan::sampling(
model,
data = model_data,
cores = cores,
seed = SEED,
#' @srrstats {G2.4,G2.4a} explicit conversion to
#'   integers for sampling arguments
chains = as.integer(n.chain),
thin = as.integer(thin),
warmup = as.integer(n.iter.burn),
iter = (
as.integer(n.iter.burn) + as.integer(n.iter.sample)
),
refresh = ifelse(verbose == TRUE,500,0)
)
n.iter.burn
