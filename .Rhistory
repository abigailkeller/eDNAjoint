model_index <- dplyr::case_when(family=='poisson'~ 1,
family=='gamma' ~ 2)
out <- rstan::sampling(c(stanmodels$joint_binary_cov_catchability_pois,
stanmodels$joint_binary_cov_catchability_gamma)[model_index][[1]],
data = rlist::list.append(
data,
nparams = length(q_names),
mat = as.matrix(count_all[,q_names]),
nsitecov = length(cov)+1,
mat_site = as.matrix(site_mat)
),
cores = cores,
chains = n.chain,
thin = thin,
warmup = n.iter.burn,
iter = n.iter.burn + n.iter.sample,
init = init_joint_cov_catchability(n.chain,count_all,q_names,cov)
)
rm(out)
devtools::load_all()
out <- rstan::sampling(c(stanmodels$joint_binary_cov_catchability_pois,
stanmodels$joint_binary_cov_catchability_gamma)[model_index][[1]],
data = rlist::list.append(
data,
nparams = length(q_names),
mat = as.matrix(count_all[,q_names]),
nsitecov = length(cov)+1,
mat_site = as.matrix(site_mat)
),
cores = cores,
chains = n.chain,
thin = thin,
warmup = n.iter.burn,
iter = n.iter.burn + n.iter.sample,
init = init_joint_cov_catchability(n.chain,count_all,q_names,cov)
)
data <- greencrabData
#convert count data to long format
count_all <- as.data.frame(data$count) %>%
dplyr::mutate(L=1:dim(data$count)[1]) %>%
tidyr::pivot_longer(cols=!L,values_to='count') %>%
tidyr::drop_na()
cores <- 1
family='negbin'
##run model, no catchability, negbin
out <- rstan::sampling(stanmodels$traditional_negbin,
data = list(
Nloc = length(unique(count_all$L)),
C = nrow(count_all),
R = count_all$L,
E = count_all$count,
phipriors = phipriors,
control = list(adapt_delta = adapt_delta)
),
cores = cores,
chains = n.chain,
thin = thin,
warmup = n.iter.burn,
iter = n.iter.burn + n.iter.sample,
init = init_trad(n.chain, count_all)
)
library(bayesplot)
install.packages('bayesplot')
library(bayesplot)
mcmc_areas(as.matrix(out), pars = c('mu[1]', 'phi'), prob = 0.8)
mcmc_areas(as.matrix(out), pars = 'phi', prob = 0.8)
mcmc_trace(extract(out), pars = 'phi')
mcmc_trace(rstan::extract(out), pars = 'phi')
test <- rstan::extract(out)
mcmc_trace(test, pars = 'phi')
str(test)
mcmc_trace(test, pars = 'mu[1]')
mcmc_trace(test, pars = 'mu')
mcmc_trace(test$phi, pars = 'phi')
test2 <- test$phi
str(test2)
mcmc_trace(rstan::extract(out, permuted = FALSE), pars = 'phi')
mcmc_trace(rstan::extract(out, permuted = FALSE), pars = c('phi', 'mu[1]')
)
devtools::document()
roxygen2::roxygenise()
devtools::install()
jointModel <- function(data, cov='None', family='poisson', p10priors=c(1,20), q=FALSE,
phipriors=c(0.25,0.25), multicore=TRUE,
n.chain=4, n.iter.burn=500,
n.iter.sample=2500, thin=1, adapt_delta=0.9) {
####
# input checks
# model with catchability coefficients
if (q==TRUE) {
catchability_checks(data,cov)
}
# model without catchability coefficients
if (q==FALSE) {
no_catchability_checks(data,cov)
}
# model with covariates
if (all(cov!='None')) {
covariate_checks(data,cov)
}
# all models
all_checks(data,cov,family,p10priors)
if (!requireNamespace("rstan", quietly = TRUE)){
stop ("The 'rstan' package is not installed.", call. = FALSE)
}
###
#convert data to long format
'%>%' <- magrittr::`%>%`
#convert qPCR data to long format
qPCR_all <- as.data.frame(data$qPCR.N) %>%
dplyr::mutate(L=1:dim(data$qPCR.N)[1]) %>%
tidyr::pivot_longer(cols=!L,values_to='N') %>%
tidyr::drop_na()
qPCR.K_df <- as.data.frame(data$qPCR.K) %>%
dplyr::mutate(L=1:dim(data$qPCR.K)[1]) %>%
tidyr::pivot_longer(cols=!L,values_to='K') %>%
tidyr::drop_na()
qPCR_all$K <- qPCR.K_df$K
#convert count data to long format
count_all <- as.data.frame(data$count) %>%
dplyr::mutate(L=1:dim(data$count)[1]) %>%
tidyr::pivot_longer(cols=!L,values_to='count') %>%
tidyr::drop_na()
#if q==TRUE, add count type data to count df
if(q==TRUE){
q_ref <- 1
count.type_df <- as.data.frame(data$count.type) %>%
dplyr::mutate(L=1:dim(data$count.type)[1]) %>%
tidyr::pivot_longer(cols=!L,values_to='count.type') %>%
tidyr::drop_na()
count_all$count.type <- count.type_df$count.type
#create vector of q coefficient names
counttypes <- unique(count_all$count.type)
names <- counttypes[!counttypes==q_ref]
q_names <- paste0('q_',names)
#add dummy variables for count type
for(i in seq_along(q_names)){
count_all[,q_names[i]] <- ifelse(count_all$count.type==names[i],1,0)
}
}
#if present, prepare covariate data
if(all(cov!='None')){
site_mat <- as.data.frame(data$site.cov[,cov])
site_mat <- cbind(as.data.frame(rep(1,length(site_mat[,1]))),site_mat)
colnames(site_mat) <- c('int',cov)
}
#convert p10 prior
#p10 prior: convert beta(1,20) to lognormal distribution
#moment match from beta(alpha,beta) to normal(mu, sigma^2)
alpha <- p10priors[1]
beta <- p10priors[2]
mu <- alpha/(alpha+beta)
sigma_2 <- (alpha*beta)/((alpha+beta)^2*(alpha+beta+1))
#convert normal(mu, sigma^2) to lognormal(mu, sigma^2)
mu_ln <- log(mu^2/sqrt(mu^2+sigma_2))
sigma_2_ln <- log(1+sigma_2/mu^2)
sigma_ln <- sqrt(sigma_2_ln)
# create data that will be present in all model variations
data <- list(
S = nrow(qPCR_all),
L = qPCR_all$L,
Nloc = length(unique(qPCR_all$L)),
N = qPCR_all$N,
K = qPCR_all$K,
C = nrow(count_all),
R = count_all$L,
E = count_all$count,
p10priors = c(mu_ln,sigma_ln),
control = list(adapt_delta = adapt_delta)
)
# set up core number
if(multicore == TRUE){
cores <- parallel::detectCores()
} else {
cores <- 1
}
##run model, catchability, pois/gamma, no covariates
if(q==TRUE&&family!='negbin'&&all(cov=='None')){
model_index <- dplyr::case_when(family=='poisson'~ 1,
family=='gamma' ~ 2)
out <- rstan::sampling(c(stanmodels$joint_binary_catchability_pois,
stanmodels$joint_binary_catchability_gamma)[model_index][[1]],
data = rlist::list.append(
data,
nparams = length(q_names),
mat = as.matrix(count_all[,q_names])
),
cores = cores,
chains = n.chain,
thin = thin,
warmup = n.iter.burn,
iter = n.iter.burn + n.iter.sample,
init = init_joint_catchability(n.chain,count_all,q_names)
)
} else if(q==TRUE&&family=='negbin'&&all(cov=='None')){
##run model, catchability, negbin, no covariates
out <- rstan::sampling(stanmodels$joint_binary_catchability_negbin,
data = rlist::list.append(
data,
phipriors = phipriors,
nparams = length(q_names),
mat = as.matrix(count_all[,q_names])
),
cores = cores,
chains = n.chain,
thin = thin,
warmup = n.iter.burn,
iter = n.iter.burn + n.iter.sample,
init = init_joint_catchability(n.chain,count_all,q_names)
)
} else if(q==FALSE&&family!='negbin'&&all(cov=='None')){
##run model, no catchability, pois/gamma, no covariates
model_index <- dplyr::case_when(family=='poisson'~ 1,
family=='gamma' ~ 2)
out <- rstan::sampling(c(stanmodels$joint_binary_pois,
stanmodels$joint_binary_gamma)[model_index][[1]],
data = data,
cores = cores,
chains = n.chain,
thin = thin,
warmup = n.iter.burn,
iter = n.iter.burn + n.iter.sample,
init = init_joint(n.chain,count_all)
)
} else if(q==FALSE&&family=='negbin'&&all(cov=='None')){
##run model, no catchability, negbin, no covariates
out <- rstan::sampling(stanmodels$joint_binary_negbin,
data = rlist::list.append(
data,
phipriors = phipriors
),
cores = cores,
chains = n.chain,
thin = thin,
warmup = n.iter.burn,
iter = n.iter.burn + n.iter.sample,
init = init_joint(n.chain,count_all)
)
} else if(q==TRUE&&family=='negbin'&&all(cov!='None')){
##run model, catchability, negbin, covariates
out <- rstan::sampling(stanmodels$joint_binary_cov_catchability_negbin,
data = rlist::list.append(
data,
phipriors = phipriors,
nparams = length(q_names),
mat = as.matrix(count_all[,q_names]),
nsitecov = length(cov)+1,
mat_site = as.matrix(site_mat)
),
cores = cores,
chains = n.chain,
thin = thin,
warmup = n.iter.burn,
iter = n.iter.burn + n.iter.sample,
init = init_joint_cov_catchability(n.chain,count_all,q_names,cov)
)
} else if(q==TRUE&&family!='negbin'&&all(cov!='None')){
##run model, catchability, pois/gamma, covariates
model_index <- dplyr::case_when(family=='poisson'~ 1,
family=='gamma' ~ 2)
out <- rstan::sampling(c(stanmodels$joint_binary_cov_catchability_pois,
stanmodels$joint_binary_cov_catchability_gamma)[model_index][[1]],
data = rlist::list.append(
data,
nparams = length(q_names),
mat = as.matrix(count_all[,q_names]),
nsitecov = length(cov)+1,
mat_site = as.matrix(site_mat)
),
cores = cores,
chains = n.chain,
thin = thin,
warmup = n.iter.burn,
iter = n.iter.burn + n.iter.sample,
init = init_joint_cov_catchability(n.chain,count_all,q_names,cov)
)
} else if(q==FALSE&&family=='negbin'&&all(cov!='None')){
##run model, no catchability, negbin, covariates
out <- rstan::sampling(stanmodels$joint_binary_cov_negbin,
data = rlist::list.append(
data,
phipriors = phipriors,
nsitecov = length(cov)+1,
mat_site = as.matrix(site_mat)
),
cores = cores,
chains = n.chain,
thin = thin,
warmup = n.iter.burn,
iter = n.iter.burn + n.iter.sample,
init = init_joint_cov(n.chain,count_all,cov)
)
} else if(q==FALSE&&family!='negbin'&&all(cov!='None')){
##run model, no catchability, pois/gamma, covariates
model_index <- dplyr::case_when(family=='poisson'~ 1,
family=='gamma' ~ 2)
out <- rstan::sampling(c(stanmodels$joint_binary_cov_pois,
stanmodels$joint_binary_cov_gamma)[model_index][[1]],
data = rlist::list.append(
data,
nsitecov = length(cov)+1,
mat_site = as.matrix(site_mat)
),
cores = cores,
chains = n.chain,
thin = thin,
warmup = n.iter.burn,
iter = n.iter.burn + n.iter.sample,
init = init_joint_cov(n.chain,count_all,cov)
)
}
return(out)
}
data(gobyData)
# run the joint model with two covariates
goby.fit <- jointModel(data = gobyData, cov=c('Filter_time','Salinity'),
family = 'poisson', p10priors = c(1,20), q=FALSE)
###########
#helper functions: initial values
###########
init_joint_cov <- function(n.chain,count_all,cov){
#helper function
#joint model, catchability coefficient, site covariates
A <- list()
for(i in 1:n.chain){
A[[i]] <- list(
mu = stats::runif(length(unique(count_all$L)), 0.01, 5),
p10 = log(0.05),
alpha = rep(0.1,length(cov)+1)
)
}
return(A)
}
init_joint_cov_catchability <- function(n.chain,count_all,q_names,cov){
#helper function
#joint model, catchability coefficient, site covariates
A <- list()
for(i in 1:n.chain){
A[[i]] <- list(
mu = stats::runif(length(unique(count_all$L)), 0.01, 5),
q = as.data.frame(stats::runif(length(q_names),0.01,1)),
p10 = log(0.05),
alpha = rep(0.1,length(cov)+1)
)
}
return(A)
}
init_joint_catchability <- function(n.chain,count_all,q_names){
#helper function
#joint model, catchability coefficient, no site covariates
A <- list()
for(i in 1:n.chain){
A[[i]] <- list(
mu = stats::runif(length(unique(count_all$L)), 0.01, 5),
q = as.data.frame(stats::runif(length(q_names),0.01,1)),
p10 = log(0.05),
beta = .5
)
}
return(A)
}
init_joint <- function(n.chain,count_all){
#helper function
#joint model, no catchability coefficient, no site covariates
A <- list()
for(i in 1:n.chain){
A[[i]] <- list(
mu = stats::runif(length(unique(count_all$L)), 0.01, 5),
p10 = log(0.05),
beta = .5
)
}
return(A)
}
################
#helper functions: input checks
################
# if q = TRUE
catchability_checks <- function(data,cov){
## All tags in data are valid (i.e., include qPCR.N, qPCR.K, count, count.type, and site.cov)
#cov='None'
if (all(cov=='None') && !all(c('qPCR.N', 'qPCR.K', 'count','count.type') %in% names(data))){
errMsg = paste("Data should include 'qPCR.N', 'qPCR.K', 'count', and 'count.type'.")
stop(errMsg)
}
#q=TRUE and cov!='None'
if (all(cov!='None') && !all(c('qPCR.N', 'qPCR.K', 'count','count.type','site.cov') %in% names(data))){
errMsg = paste("Data should include 'qPCR.N', 'qPCR.K', 'count', 'count.type', and 'site.cov'.")
stop(errMsg)
}
## make sure dimensions of count and count.type are equal, if count.type is present
if(dim(data$count)[1]!=dim(data$count.type)[1]|dim(data$count)[2]!=dim(data$count.type)[2]) {
errMsg = paste("Dimensions of count and count.type do not match.")
stop(errMsg)
}
## make sure all data is numeric -- if q == TRUE
if(is.numeric(data$qPCR.K)==FALSE |
is.numeric(data$qPCR.N)==FALSE |
is.numeric(data$count)==FALSE |
is.numeric(data$count.type)==FALSE) {
errMsg = paste("Data should be numeric.")
stop(errMsg)
}
## make sure locations of NAs in count data match locations of NAs in count.type data
if(sum(is.na(data$count.type))!=sum(is.na(data$count))){
errMsg = paste("Empty data cells (NA) in count data should match empty data cells (NA) in count.type data.")
stop(errMsg)
}
if(any((which(is.na(data$count))==which(is.na(data$count.type)))==FALSE)){
errMsg = paste("Empty data cells (NA) in count data should match empty data cells (NA) in count.type data.")
stop(errMsg)
}
## the smallest count.type is 1
if(min(data$count.type,na.rm=TRUE) != 1){
errMsg = paste("The first gear type should be referenced as 1 in count.type. Subsequent gear types should be referenced 2, 3, 4, etc.")
stop(errMsg)
}
## count.type are integers
if(!all(data$count.type %% 1 %in% c(0,NA))){
errMsg = paste("All values in count.type should be integers.")
stop(errMsg)
}
}
no_catchability_checks <- function(data,cov){
## All tags in data are valid (i.e., include qPCR.N, qPCR.K, count, and site.cov)
#cov='None'
if (all(cov=='None') && !all(c('qPCR.N', 'qPCR.K', 'count') %in% names(data))){
errMsg = paste("Data should include 'qPCR.N', 'qPCR.K', and 'count'.")
stop(errMsg)
}
#cov!='None'
if (all(cov!='None') && !all(c('qPCR.N', 'qPCR.K', 'count','site.cov') %in% names(data))){
errMsg = paste("Data should include 'qPCR.N', 'qPCR.K', 'count', and 'site.cov'.")
stop(errMsg)
}
## make sure all data is numeric -- if q == FALSE
if(is.numeric(data$qPCR.K)==FALSE |
is.numeric(data$qPCR.N)==FALSE |
is.numeric(data$count)==FALSE ) {
errMsg = paste("Data should be numeric.")
stop(errMsg)
}
}
all_checks <- function(data,cov,family,p10priors){
## make sure dimensions of qPCR.N and qPCR.K are equal
if (dim(data$qPCR.N)[1]!=dim(data$qPCR.K)[1]|dim(data$qPCR.N)[2]!=dim(data$qPCR.K)[2]) {
errMsg = paste("Dimensions of qPCR.N and qPCR.K do not match.")
stop(errMsg)
}
## make sure number of rows in count = number of rows in qPCR.N and qPCR.K
if (dim(data$qPCR.N)[1]!=dim(data$count)[1]) {
errMsg = paste("Number of sites (rows) in qPCR data and traditional survey count data do not match.")
stop(errMsg)
}
## make sure locations of NAs in qPCR.N data match locations of NAs in qPCR.K data
if(any((which(is.na(data$qPCR.N))==which(is.na(data$qPCR.K)))==FALSE)){
errMsg = paste("Empty data cells (NA) in qPCR.N data should match empty data cells (NA) in qPCR.K data.")
stop(errMsg)
}
## make sure family is either 'poisson', 'negbin', or 'gamma'
if(!c(family %in% c('poisson','negbin','gamma'))){
errMsg = paste("Invalid family. Options include 'poisson', 'negbin', and 'gamma'.")
stop(errMsg)
}
## p10priors is a vector of two integers
if(!is.numeric(p10priors) | length(p10priors)!=2 | any(phipriors<=0)){
errMsg = paste("p10priors should be a vector of two numeric values > 0. ex. c(1,20)")
stop(errMsg)
}
## phipriors is a vector of two numeric values
if(!is.numeric(phipriors) | length(phipriors)!=2 | any(phipriors<=0)){
errMsg = paste("phipriors should be a vector of two numeric values > 0. ex. c(0.25,0.25)")
stop(errMsg)
}
## count are integers, if family is poisson or negbin
if(!all(data$count %% 1 %in% c(0,NA)) && family %in% c('poisson','negbin')){
errMsg = paste("All values in count should be integers. Use family = 'gamma' if count is continuous.")
stop(errMsg)
}
## qPCR.N are integers
if(!all(data$qPCR.N %% 1 %in% c(0,NA))){
errMsg = paste("All values in qPCR.N should be integers.")
stop(errMsg)
}
## qPCR.K are integers
if(!all(data$qPCR.K %% 1 %in% c(0,NA))){
errMsg = paste("All values in qPCR.K should be integers.")
stop(errMsg)
}
}
covariate_checks <- function(data,cov){
## site.cov is numeric, if present
if(!is.numeric(data$site.cov)){
errMsg = paste("site.cov should be numeric.")
stop(errMsg)
}
## cov values match column names in site.cov
if(!all(cov %in% colnames(data$site.cov))){
errMsg = paste("cov values should be listed in the column names of site.cov in the data.")
stop(errMsg)
}
## site.cov has same number of rows as qPCR.N and count, if present
if(dim(data$qPCR.N)[1]!=dim(data$site.cov)[1]){
errMsg = paste("The number of rows in site.cov matrix should match the number of rows in all other matrices.")
stop(errMsg)
}
}
# run the joint model with two covariates
goby.fit <- jointModel(data = gobyData, cov=c('Filter_time','Salinity'),
family = 'poisson', p10priors = c(1,20), q=FALSE)
devtools::install()
devtools::install()
