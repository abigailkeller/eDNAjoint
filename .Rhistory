"The first gear type should be referenced as 1 in count.type. Subsequent gear types should be referenced 2, 3, 4, etc.")
expect_error(jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4.1,1,1),c(1,1,NA)),
count.type=rbind(c(0,1,2),c(1,2,NA))),
q=TRUE),
"All values in count should be integers.")
expect_error(jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4.1,1,1),c(1,1,NA)),
count.type=rbind(c(1,1,2),c(1,2,NA))),
q=TRUE),
"All values in count should be integers.")
devtools::load_all()
#16. count are integers
expect_error(jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4.1,1,1),c(1,1,NA)),
count.type=rbind(c(1,1,2),c(1,2,NA))),
q=TRUE),
"All values in count should be integers.")
#17. qPCR.N are integers
expect_error(jointModel(data=list(qPCR.N=rbind(c(0.99,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c(1,1,2),c(1,2,NA))),
q=TRUE),
"All values in qPCR.N should be integers.")
expect_error(jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3.1,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c(1,1,2),c(1,2,NA))),
q=TRUE),
"All values in qPCR.K should be integers.")
#19. count.type are integers
expect_error(jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c(1.1,1,2),c(1,2,NA))),
q=TRUE),
"All values in count.type should be integers.")
site.cov=rbind(c('high','low'),c(0.4,-0.4))
colnames(site.cov)=c('var_a','var_b')
expect_error(jointModel(data=list(qPCR.n=rbind(c(1,1,1),c(1,1,NA)),
qPCR.k=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c(1,2,1),c(1,2,NA)),
site.cov=site.cov),
cov=c('var_a','var_b'),q=TRUE),
"site.cov should be numeric")
site.cov=rbind(c('high','low'),c(0.4,-0.4))
colnames(site.cov)=c('var_a','var_b')
expect_error(jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c(1,2,1),c(1,2,NA)),
site.cov=site.cov),
cov=c('var_a','var_b'),q=TRUE),
"site.cov should be numeric")
site.cov=rbind(c('high','low'),c(0.4,-0.4))
colnames(site.cov)=c('var_a','var_b')
expect_error(jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c(1,2,1),c(1,2,NA)),
site.cov=site.cov),
cov=c('var_a','var_c'),q=TRUE),
"cov values should be listed in the column names of site.cov in the data")
site.cov=rbind(c(0,1),c(0.4,-0.4))
colnames(site.cov)=c('var_a','var_b')
expect_error(jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c(1,2,1),c(1,2,NA)),
site.cov=site.cov),
cov=c('var_a','var_c'),q=TRUE),
"cov values should be listed in the column names of site.cov in the data")
site.cov=rbind(c(0,1),c(0.4,-0.4))
expect_error(jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c(1,2,1),c(1,2,NA)),
site.cov=site.cov),
cov=c('var_a','var_b'),q=TRUE),
"cov values should be listed in the column names of site.cov in the data")
rbind(c(0,1,1),c(0.4,-0.4,1)
)
cbind(c(0,1,1),c(0.4,-0.4,1)
)
#22. site.cov has same number of rows as qPCR.N and count, if present
site.cov=cbind(c(0,1,1),c(0.4,-0.4,1))
colnames(site.cov)=c('var_a','var_b')
expect_error(jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c(1,2,1),c(1,2,NA)),
site.cov=site.cov),
cov=c('var_a','var_c'),q=TRUE),
"The number of rows in site.cov matrix should match the number of rows in all other matrices.")
expect_error(jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c(1,2,1),c(1,2,NA)),
site.cov=site.cov),
cov=c('var_a','var_b'),q=TRUE),
"The number of rows in site.cov matrix should match the number of rows in all other matrices.")
rbind(c(0,1),c(0.4,-0.4))
jointModel(data=list(qPCR.N=rbind(c(1,1,1),c(1,1,NA)),
qPCR.K=rbind(c(3,3,3),c(3,3,NA)),
count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c(1,2,1),c(1,2,NA))),
q=TRUE)
out <- jointModel(data=greencrabData,q=TRUE,n.chain=1)
out <- jointModel(data=greencrabData,q=TRUE,n.chain=1,n.iter.burn=100,
n.iter.sample=500)
out <- jointModel(data=greencrabData,q=TRUE,n.chain=1,n.iter.burn=500,
n.iter.sample=500)
data <- greencrabData
test <- list(qPCR.N=greencrabData[1:10,],)
test <- list(qPCR.N=greencrabData$qPCR.N[1:10,],
qPCR.K=greencrabData$qPCR.K[1:10,],
count=greencrabData$count[1:10,],
count.type=greencrabData$count.type[1:10,])
out <- jointModel(data=test,q=TRUE,family='negbin',n.chain=1,n.iter.burn=500,
n.iter.sample=500)
summary(out)
out
library(rstan)
out2 <- as.matrix(out)
out2[,'log_lik']
View(out2)
out2[,'log_lik[604']
out2[,'log_lik[604]']
help(extract)
out3 <- extract(out,par='log_lik')
out4 <- colMeans(extract(out,par='log_lik'))
out4 <- colMeans(extract(out,par='log_lik')$log_lik)
out4 <- sum(colMeans(extract(out,par='log_lik')$log_lik))
out4
expect_lt(sum(colMeans(extract(out,par='log_lik')$log_lik)), 0)
data <- gobyData
test <- list(qPCR.N=gobyData$qPCR.N[1:10,],
qPCR.K=gobyData$qPCR.K[1:10,],
count=gobyData$count[1:10,],
site.cov=gobyData$site.cov[1:10,])
test <- list(qPCR.N=gobyData$qPCR.N[1:10,],
qPCR.K=gobyData$qPCR.K[1:10,],
count=gobyData$count[1:10,],
site.cov=gobyData$site.cov[1:10,])
out <- jointModel(data=test,q=FALSE,family='negbin',
cov=c('Filter_time','Salinity'),
n.chain=1,n.iter.burn=500,
n.iter.sample=500)
sum(colMeans(extract(out,par='log_lik')$log_lik))
expect_lt(sum(colMeans(extract(out,par='log_lik')$log_lik)), 0)
dim(gobyData$count[1:10,])
matrix(1,10,22)
test <- list(qPCR.N=gobyData$qPCR.N[1:10,],
qPCR.K=gobyData$qPCR.K[1:10,],
count=gobyData$count[1:10,],
count.type=matrix(1,10,22),
site.cov=gobyData$site.cov[1:10,])
out <- jointModel(data=test,q=TRUE,family='negbin',
cov=c('Filter_time','Salinity'),
n.chain=1,n.iter.burn=500,
n.iter.sample=500)
gobyData$count[1:10,]
jointModel(data=test,q=TRUE,family='negbin',
cov=c('Filter_time','Salinity'),
n.chain=1,n.iter.burn=500,
n.iter.sample=500)
gobyData$count[1:10,]
test <- list(qPCR.N=gobyData$qPCR.N[1:10,],
qPCR.K=gobyData$qPCR.K[1:10,],
count=gobyData$count[1:10,],
count.type=matrix(1,10,22),
site.cov=gobyData$site.cov[1:10,])
data <- test
which(is.na(data$count.type))
any((which(is.na(data$count.type))==which(is.na(data$count)))
==FALSE)
any((which(is.na(data$count))==which(is.na(data$count.type)))==FALSE)
is.na(data$count)
is.na(data$count))==which(is.na(data$count.type)
which(is.na(data$count))==which(is.na(data$count.type)
)
which(is.na(data$count.type)
)
is.na(data$count.type)
count.type <- matrix(1,10,22)
nrow(count.type)
count <- gobyData$count[1:10,]
count.type <- matrix(1,10,22)
for(i in 1:nrow(count.type)){
for(j in 1:ncol(count.type)){
count.type[i,j] <- ifelse(is.na(count[i,j]),NA,1)
}
}
count <- gobyData$count[1:10,]
count.type <- matrix(1,10,22)
for(i in 1:nrow(count.type)){
for(j in 1:ncol(count.type)){
count.type[i,j] <- ifelse(is.na(count[i,j]),NA,1)
}
}
test <- list(qPCR.N=gobyData$qPCR.N[1:10,],
qPCR.K=gobyData$qPCR.K[1:10,],
count=count,
count.type=count.type,
site.cov=gobyData$site.cov[1:10,])
out <- jointModel(data=test,q=TRUE,family='negbin',
cov=c('Filter_time','Salinity'),
n.chain=1,n.iter.burn=500,
n.iter.sample=500)
count
count.type
length(count[1,])
length(!is.na(count[1,]))
count[1,]
is.na(count[1,])
length(is.na(count[1,])==FALSE)
length(count[1,][!is.na(count[1,])])
n <- length(count[1,][!is.na(count[1,])])
n_1 <- round(n/2)
n_1
n_2 <- n - n_1
c(rep(1,n_1),rep(2,n_2))
count <- gobyData$count[1:10,]
count.type <- matrix(NA,10,22)
for(i in 1:nrow(count.type)){
n <- length(count[1,][!is.na(count[1,])])
n_1 <- round(n/2)
n_2 <- n - n_1
count.type[i,1:n] <- c(rep(1,n_1),rep(2,n_2))
}
count.type
count <- gobyData$count[1:10,]
count.type <- matrix(NA,10,22)
for(i in 1:nrow(count.type)){
n <- length(count[i,][!is.na(count[i,])])
n_1 <- round(n/2)
n_2 <- n - n_1
count.type[i,1:n] <- c(rep(1,n_1),rep(2,n_2))
}
count.type
test <- list(qPCR.N=gobyData$qPCR.N[1:10,],
qPCR.K=gobyData$qPCR.K[1:10,],
count=count,
count.type=count.type,
site.cov=gobyData$site.cov[1:10,])
out <- jointModel(data=test,q=TRUE,family='negbin',
cov=c('Filter_time','Salinity'),
n.chain=1,n.iter.burn=500,
n.iter.sample=500)
sum(colMeans(extract(out,par='log_lik')$log_lik))
data
sum(is.na(data$count.type))
sum(is.na(data$count))
q <- TRUE
## #7. make sure locations of NAs in count data match locations of NAs in count.type data
if(q==TRUE){
if(sum(is.na(data$count.type))!=sum(is.na(data$count))){
errMsg = paste("Empty data cells (NA) in count data should match empty data cells (NA) in count.type data.")
print(errMsg)
}
}
devtools::load_all()
#1. input tags are valid, q = TRUE
expect_error(traditionalModel(data=list(Count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c(1,2,1),c(1,2,NA)))),
"Data should include 'count' and 'count.type'.")
#1. input tags are valid, q = TRUE
expect_error(traditionalModel(data=list(Count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c(1,2,1),c(1,2,NA))),q=TRUE),
"Data should include 'count' and 'count.type'.")
devtools::load_all()
#2. input tags are valid, q = FALSE
expect_error(traditionalModel(data=list(Count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c(1,2,1),c(1,2,NA)))),
"Data should include 'count' and 'count.type'.")
#2. input tags are valid, q = FALSE
expect_error(traditionalModel(data=list(Count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c(1,2,1),c(1,2,NA)))),
"Data should include 'count' and 'count.type'.")
#2. input tags are valid, q = FALSE
expect_error(traditionalModel(data=list(Count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c(1,2,1),c(1,2,NA)))),
"Data should include 'count' and 'count.type'.")
#2. input tags are valid, q = FALSE
expect_error(traditionalModel(data=list(Count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c(1,2,1),c(1,2,NA))),q=FALSE),
"Data should include 'count' and 'count.type'.")
#2. input tags are valid, q = FALSE
expect_error(traditionalModel(data=list(Count=c(4,1,1),c(1,1,NA))),
"Data should include 'count' and 'count.type'.")
#2. input tags are valid, q = FALSE
expect_error(traditionalModel(data=list(Count=c(4,1,1),c(1,1,NA))),
"Data should include 'count'.")
#3. make sure dimensions of count and count.type are equal, if count.type is present
expect_error(traditionalModel(data=list(count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c(1,2),c(1,2))),
q=TRUE),
"Dimensions of count and count.type do not match.")
#4. make sure all data is numeric -- if q == TRUE
expect_error(traditionalModel(data=list(count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c('NA',2,2),c(1,2,2))),
q=TRUE),
"Data should be numeric \\(i.e. contain integers or NA\\).")
#5. make sure all data is numeric -- if q == FALSE
expect_error(traditionalModel(data=list(count=c(4,1,1),c(1,1,NA))),
"Data should be numeric \\(i.e. contain integers or NA\\).")
#5. make sure all data is numeric -- if q == FALSE
expect_error(traditionalModel(data=list(count=rbind(c(4,1,1),c(1,1,'NA')))),
"Data should be numeric \\(i.e. contain integers or NA\\).")
#6. make sure locations of NAs in count data match locations of NAs in count.type data
expect_error(traditionalModel(data=list(count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c(NA,2,2),c(1,2,2))),
q=TRUE),
"Empty data cells \\(NA\\) in count data should match empty data cells \\(NA\\) in count.type data.")
#7. make sure family is either 'poisson' or 'negbin'
expect_error(traditionalModel(data=list(count=rbind(c(4,1,1),c(1,1,NA))),
family='normal'),
"Invalid family. Options include 'poisson' and 'negbin'.")
#8. the smallest count.type is 1
expect_error(traditionalModel(data=list(count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c(0,1,2),c(1,2,NA))),
q=TRUE),
"The first gear type should be referenced as 1 in count.type. Subsequent gear types should be referenced 2, 3, 4, etc.")
#9. count are integers
expect_error(traditionalModel(data=list(count=rbind(c(4.1,1,1),c(1,1,NA)),
count.type=rbind(c(1,1,2),c(1,2,NA))),
q=TRUE),
"All values in count should be integers.")
#10. count.type are integers
expect_error(traditionalModel(data=list(count=rbind(c(4,1,1),c(1,1,NA)),
count.type=rbind(c(1.1,1,2),c(1,2,NA))),
q=TRUE),
"All values in count.type should be integers.")
test_that("traditionaly_catchability_pois works", {
test <- list(count=greencrabData$count[1:10,],
count.type=greencrabData$count.type[1:10,])
out <- traditionalModel(data=test,q=TRUE,n.chain=1,n.iter.burn=500,
n.iter.sample=500)
expect_lt(sum(colMeans(extract(out,par='log_lik')$log_lik)), 0)
})
test_that("traditional_catchability_pois works", {
test <- list(count=greencrabData$count[1:10,],
count.type=greencrabData$count.type[1:10,])
out <- traditionalModel(data=test,q=TRUE,n.chain=1,n.iter.burn=500,
n.iter.sample=500)
expect_lt(sum(colMeans(rstan::extract(out,par='log_lik')$log_lik)), 0)
})
test_that("traditional_catchability_negbin works", {
test <- list(count=greencrabData$count[1:10,],
count.type=greencrabData$count.type[1:10,])
out <- traditionalModel(data=test,q=TRUE,family='negbin',n.chain=1,n.iter.burn=500,
n.iter.sample=500)
expect_lt(sum(colMeans(rstan::extract(out,par='log_lik')$log_lik)), 0)
})
test_that("traditional_pois works", {
test <- list(count=greencrabData$count[1:10,])
out <- traditionalModel(data=test,n.chain=1,n.iter.burn=500,
n.iter.sample=500)
expect_lt(sum(colMeans(rstan::extract(out,par='log_lik')$log_lik)), 0)
})
test_that("traditional_negbin works", {
test <- list(count=greencrabData$count[1:10,])
out <- traditionalModel(data=test,family='negbin',n.chain=1,n.iter.burn=500,
n.iter.sample=500)
expect_lt(sum(colMeans(rstan::extract(out,par='log_lik')$log_lik)), 0)
})
out <- lm(c(1,2,3) ~ c(1,2,3))
data <- data.frame(y=c(1,2,3),x=(1,2,3))
data <- data.frame(y=c(1,2,3),x=c(1,2,3))
out <- lm(y ~ x, data,data)
out <- lm(y ~ x, data=data)
out
#1. make sure model fit is of class stanfit
data <- data.frame(y=c(1,2,3),x=c(1,2,3))
out <- lm(y ~ x, data,data)
expect_error(summarize(out),
"modelfit must be of class 'stanfit'.")
out <- lm(y ~ x, data=data)
expect_error(summarize(out),
"modelfit must be of class 'stanfit'.")
test <- list(qPCR.N=greencrabData$qPCR.N[1:10,],
qPCR.K=greencrabData$qPCR.K[1:10,],
count=greencrabData$count[1:10,],
count.type=greencrabData$count.type[1:10,])
out <- jointModel(data=test,q=TRUE,family='negbin',n.chain=1,n.iter.burn=500,
n.iter.sample=500)
devtools::load_all()
#2. make sure probs is a numeric vector
expect_error(summarize(out,probs=c('95%')),
"probs must be a numeric vector.")
#3. make sure par is a character vector
expect_error(summarize(out,par=c(1,2,3)),
"par must be a character vector.")
##4. make sure model fit contains all par input
par <- 'alpha'
expect_error(summarize(out,par=par),
"modelfit must contain all selected parameters: ",par,".")
devtools::load_all()
#4. make sure model fit contains all par input
par <- 'alpha'
expect_error(summarize(out,par=par),
paste0("modelfit must contain all selected parameters: ",par))
paste0("modelfit must contain all selected parameters: ",par)
expect_error(summarize(out,par='alpha'),
"modelfit must contain all selected parameters: alpha")
paste("modelfit must contain all selected parameters: ",par)
#4. make sure model fit contains all par input
expect_error(summarize(out,par='alpha'),
"modelfit must contain all selected parameters:  alpha")
devtools::load_all()
#4. make sure model fit contains all par input
expect_error(summarize(out,par='alpha'),
"modelfit must contain all selected parameters: alpha")
summarize(out,probs=c(0,100))
summarize(out,probs=c(0,1))
summarize(out,probs=c(0.01,0.99))
summarize(out,probs=c(0.05,0.99))
summarize(out,probs=c(0.05,0.95))
modelfit <- out
all(c('p10','q','phi','beta') %in% modelfit@model_pars)==TRUE &&
!c('alpha') %in% modelfit@model_pars &&
all(par == 'all')
all(c('p10','beta','q') %in% modelfit@model_pars)==TRUE &&
all(!c('phi','alpha') %in% modelfit@model_pars) &&
all(par == 'all')
all(c('p10','phi','beta') %in% modelfit@model_pars)==TRUE &&
all(!c('q','alpha') %in% modelfit@model_pars) &&
all(par == 'all')
all(c('p10','beta') %in% modelfit@model_pars)==TRUE &&
all(!c('q','phi','alpha') %in% modelfit@model_pars==TRUE) &&
all(par == 'all')
all(c('p10','q','phi','alpha') %in% modelfit@model_pars)==TRUE &&
all(par == 'all')
par <- 'all'
all(c('p10','q','phi','beta') %in% modelfit@model_pars)==TRUE &&
!c('alpha') %in% modelfit@model_pars &&
all(par == 'all')
rstan::summary(modelfit,pars=c('p10','beta','q','phi','mu'),probs=probs,use_cache=FALSE)
probs <- c(0.025,0.975)
rstan::summary(modelfit,pars=c('p10','beta','q','phi','mu'),probs=probs,use_cache=FALSE)
rstan::summary(modelfit,pars=c('p10','beta','q','phi','mu'),probs=probs,use_cache=FALSE)$summary
summarize(out,probs=c(0.05,0.95))
summarize(out,probs=c(0.025,0.975))
modelfit@mode
test <- as.array(modelfit)
test$chains
dimnames(test)
probs <- c(0.01,0.99)
rstan::summary(modelfit,pars=c('p10','beta','q','phi','mu'),probs=probs,use_cache=FALSE)$summary
probs <- c(0,1)
rstan::summary(modelfit,pars=c('p10','beta','q','phi','mu'),probs=probs,use_cache=FALSE)$summary
probs
any(probs > 1 | probs < 0)
!any(probs > 1 | probs < 0)
probs
any(probs > 1)
any(probs > 1 | probs < 0)
probs > 1 | probs < 0
class(out)
test
out_array <- as.array(out)
out_array$chains
get_elapsed_time(out)
rstan::get_elapsed_time(out)
as.data.frame(rstan::get_elapsed_time(out))
dim(as.data.frame(rstan::get_elapsed_time(out)))
dim(as.data.frame(rstan::get_elapsed_time(out)))[1]
## #5. check to see if there are any divergent transitions
nchains <- dim(as.data.frame(rstan::get_elapsed_time(out)))[1]
nchains
test <-rstan::get_sampler_params(modelfit,inc_warmup=FALSE)
x <- rstan::get_sampler_params(modelfit,inc_warmup=FALSE)
x <- rstan::get_sampler_params(modelfit,inc_warmup=FALSE)[[1]]
#function to check for divergent transitions
div_check <- function(x){
divergent <- x[,'divergent__']
return(divergent)
}
div_check(x[[1]])
x[[1]]
x
test <- rstan::get_sampler_params(modelfit,inc_warmup=FALSE)
test[[,'divergent__']]
test[,'divergent__']
test[[1]][,'divergent__']
sum(test[[1]][,'divergent__'])
x <- test[[1]]
#function to check for divergent transitions
div_check <- function(x){
divergent <- sum(x[,'divergent__'])
return(divergent)
}
div_check(x[[1]])
div_check(test[[1]])
lapply(rstan::get_sampler_params(modelfit,inc_warmup=FALSE),div_check)
sum(lapply(rstan::get_sampler_params(modelfit,inc_warmup=FALSE),div_check))
sum(lapply(rstan::get_sampler_params(modelfit,inc_warmup=FALSE),div_check)[[1]])
devtools::load_all()
#3. make sure all values of probs are between 0 and 1
expect_error(summarize(out,probs=c(5,95)),
"probs must be between 0 and 1.")
#4. make sure par is a character vector
expect_error(summarize(out,par=c(1,2,3)),
"par must be a character vector.")
#5. make sure model fit contains all par input
expect_error(summarize(out,par='alpha'),
"modelfit must contain all selected parameters: alpha")
